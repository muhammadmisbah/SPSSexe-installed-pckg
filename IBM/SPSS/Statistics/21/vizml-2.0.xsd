<?xml version="1.0" encoding="UTF-8"?>
<!-- ***************************************************************** -->
<!--                                                                   -->
<!-- Licensed Materials - Property of IBM                              -->
<!--                                                                   -->
<!-- IBM SPSS Products: Visualization Platform                         -->
<!--                                                                   -->
<!-- (C) Copyright IBM Corp. 2003, 2011                                -->
<!--                                                                   -->
<!-- US Government Users Restricted Rights - Use, duplication or       -->
<!-- disclosure restricted by GSA ADP Schedule Contract with IBM       -->
<!-- Corp.                                                             -->
<!--                                                                   -->
<!-- ***************************************************************** -->


<!-- edited with XMLSpy v2005 rel. 3 U (http://www.altova.com) by JEANNETTE E. JONES (SPSS INC.) -->
<xs:schema xmlns:vis="http://xml.spss.com/visualization" xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="http://xml.spss.com/visualization" elementFormDefault="qualified" attributeFormDefault="unqualified" version="2.0">
    <xs:annotation>
        <xs:documentation xml:lang="en">Copyright 2005 SPSS Inc - All Rights Reserved.  SPSS specifically disclaims all warranties with respect to your use of this specification, expressed, implied, or otherwise, including without limitation, all warranties of merchantability and fitness for a particular purpose.  SPSS shall not be liable for any special, incidental, or consequential damages, including without limitation lost revenues or lost profits resulting from the use of the information herein.</xs:documentation>
    </xs:annotation>
    <xs:element name="visualization">
        <xs:annotation>
            <xs:documentation>The visualization element is the top level element in a visualization; also known as the Document Element. This element contains a complete specification of a visualization</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:frame">
                    <xs:sequence>
                        <xs:choice minOccurs="0" maxOccurs="unbounded">
                            <xs:annotation>
                                <xs:documentation>Sources</xs:documentation>
                            </xs:annotation>
                            <xs:element ref="vis:animatedSource"/>
                            <xs:element ref="vis:databaseSource"/>
                            <xs:element ref="vis:delimitedFileSource"/>
                            <xs:element ref="vis:embeddedSource"/>
                            <xs:element ref="vis:streamingSource"/>
                            <xs:element ref="vis:userSource"/>
                        </xs:choice>
                        <xs:choice minOccurs="0" maxOccurs="unbounded">
                            <xs:annotation>
                                <xs:documentation>Variables and data</xs:documentation>
                            </xs:annotation>
                            <xs:element ref="vis:sourceVariable"/>
                            <xs:element ref="vis:derivedVariable"/>
                            <xs:element ref="vis:expressionVariable"/>
                            <xs:element ref="vis:categoricalDomain"/>
                            <xs:element ref="vis:intervalDomain"/>
                        </xs:choice>
                        <xs:choice minOccurs="0" maxOccurs="unbounded">
                            <xs:annotation>
                                <xs:documentation>frames</xs:documentation>
                            </xs:annotation>
                            <xs:element ref="vis:graph"/>
                            <xs:element ref="vis:container"/>
                            <xs:element ref="vis:legend"/>
                            <xs:element ref="vis:labelFrame"/>
                            <xs:element ref="vis:controlFrame"/>
                        </xs:choice>
                        <xs:choice minOccurs="0" maxOccurs="unbounded">
                            <xs:annotation>
                                <xs:documentation>styles</xs:documentation>
                            </xs:annotation>
                            <xs:element ref="vis:style"/>
                            <xs:element ref="vis:styleCycle"/>
                        </xs:choice>
                        <xs:group ref="vis:interaction" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                    <xs:attribute name="lang" type="xs:language">
                        <xs:annotation>
                            <xs:documentation>Determines the language of the graph.  If no language is specified, the local language will be determined from the operating system.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="name" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>For documentation; not used directly to generate a visualization</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="author" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>For documentation; not used directly to generate a visualization</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="description" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>For documentation; not used directly to generate a visualization</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="version" type="xs:float" use="required">
                        <xs:annotation>
                            <xs:documentation>The specification version. This is usually the same as the schema version, but may be less, for example when a schema has been updated to a more recent version. If any of the meanings of schema elements have changed (which is very rare), this attribute determines what the behavior is to be</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="creator" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>For documentation; not used directly to generate a visualization</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="date" type="xs:date">
                        <xs:annotation>
                            <xs:documentation>For documentation; not used directly to generate a visualization</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="type" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>For documentation; not used directly to generate a visualization</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="container">
        <xs:annotation>
            <xs:documentation>A Frame that contains other frames (containers, graphs, legends and text frame)</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:frame">
                    <xs:choice minOccurs="0" maxOccurs="unbounded">
                        <xs:element ref="vis:container"/>
                        <xs:element ref="vis:graph"/>
                        <xs:element ref="vis:legend"/>
                        <xs:element ref="vis:labelFrame"/>
                        <xs:element ref="vis:controlFrame"/>
                    </xs:choice>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="controlFrame">
        <xs:annotation>
            <xs:documentation>A Frame that contains a visualization control</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:frame">
                    <xs:attribute name="targetSpecification" type="xs:IDREF">
                        <xs:annotation>
                            <xs:documentation>The specification to change</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="targetAttribute" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>The attribute on the tagret specification to change</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="min" type="xs:double">
                        <xs:annotation>
                            <xs:documentation>The minimum value to allow the target attribute to be</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="title" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>Title for the control</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="max" type="xs:double">
                        <xs:annotation>
                            <xs:documentation>The maximum value to allow the target attribute to be</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="divisions" type="xs:int">
                        <xs:annotation>
                            <xs:documentation>The step size between min and max values</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="labelFrame">
        <xs:annotation>
            <xs:documentation>A Frame that contains a text label</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:frame">
                    <xs:sequence>
                        <xs:element ref="vis:label"/>
                    </xs:sequence>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="label">
        <xs:annotation>
            <xs:documentation>A title or other label</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:labelType"/>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="alternateLabel">
        <xs:annotation>
            <xs:documentation>An alternative label to use for different locales</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:labelType">
                    <xs:attribute name="lang" type="xs:language">
                        <xs:annotation>
                            <xs:documentation>If multiple labels are specified, the one most closely matching the language of the chart will be used</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="legend">
        <xs:annotation>
            <xs:documentation>A Legend displays a frame containing small representations of graphical elements (called 'swatches') and some text showing what they represent. Each legend frame may have show several elements and their values</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:frame">
                    <xs:sequence>
                        <xs:element ref="vis:label" minOccurs="0"/>
                        <xs:element name="legendTarget" maxOccurs="unbounded">
                            <xs:annotation>
                                <xs:documentation>A component of the legend. A simple legend will have one target. If multiple targets are present, all the generated ticks will be concatenated together</xs:documentation>
                            </xs:annotation>
                            <xs:complexType>
                                <xs:attribute name="id" type="xs:ID" >
                                    <xs:annotation>
                                        <xs:documentation>Identifier for this element</xs:documentation>
                                    </xs:annotation>
                                </xs:attribute>
                                <xs:attribute name="target" type="xs:IDREF" use="required">
                                    <xs:annotation>
                                        <xs:documentation>The target to show in the legend. This may be an aesthetic, in which case ticks and swatches are drawn to show how the aesthetic maps to data, or it may be an element or guide, in which case a single swatch and key are shown giving the name of the element or guide and its appearance </xs:documentation>
                                    </xs:annotation>
                                </xs:attribute>
                                <xs:attribute name="domain" type="xs:IDREF">
                                    <xs:annotation>
                                        <xs:documentation>A domain specifying which entries may be shown in the legend.  Normally this is inferred from the aesthetic involved.</xs:documentation>
                                    </xs:annotation>
                                </xs:attribute>
                                <xs:attribute name="link" type="xs:anyURI">
                                    <xs:annotation>
                                        <xs:documentation>A URI that will be followed when this legend target is clicked on</xs:documentation>
                                    </xs:annotation>
                                </xs:attribute>
                            </xs:complexType>
                        </xs:element>
                    </xs:sequence>
                    <xs:attribute name="tickTextStyle" type="xs:IDREF">
                        <xs:annotation>
                            <xs:documentation>The style to draw the tick labels for the legend key</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="tickFrameStyle" type="xs:IDREF">
                        <xs:annotation>
                            <xs:documentation>The style for the plaque surrounding the tick labels for the legend key</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="reverse" type="xs:boolean" default="false">
                        <xs:annotation>
                            <xs:documentation>If true, the legend will be displayed in reverse order</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="verticalFlow" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>If true, the legend will be displayed vertically, if false the legend will be displayed horizontically</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="numberOfRows" type="xs:int">
                        <xs:annotation>
                            <xs:documentation>The desired number of rows in the legend</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="numberOfColumns" type="xs:int">
                        <xs:annotation>
                            <xs:documentation>The desired number of columns in the legend</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="location">
        <xs:annotation>
            <xs:documentation>The bounds of the frame, specified relative to the parent frame</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID"/>
            <xs:attribute name="part" type="vis:locationPartType" use="required">
                <xs:annotation>
                    <xs:documentation>What part of the location this element defines   </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="method" type="vis:locationMethodType">
                <xs:annotation>
                    <xs:documentation>The method used to define the location</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="value" type="vis:length">
                <xs:annotation>
                    <xs:documentation>Defines the desired value for the frame part location</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="min" type="vis:length">
                <xs:annotation>
                    <xs:documentation>Defines a minimum value that will override the desired value when applicable</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="max" type="vis:length">
                <xs:annotation>
                    <xs:documentation>Defines a maximum value that will override the desired value when applicable</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="target" type="xs:IDREF">
                <xs:annotation>
                    <xs:documentation>For a method that is relative to another frame, this defines the target frame</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="graph">
        <xs:annotation>
            <xs:documentation>A frame that defines coordinates, elements, aesthetics and other entites to produe a statistical graph</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:frame">
                    <xs:sequence>
                        <xs:element ref="vis:coordinates" minOccurs="0" maxOccurs="unbounded"/>
                        <xs:element ref="vis:faceting" minOccurs="0"/>
                        <xs:element name="facetLayout" minOccurs="0">
                            <xs:annotation>
                                <xs:documentation>A description of how to lbel and layout levels of a tableFacet</xs:documentation>
                            </xs:annotation>
                            <xs:complexType>
                                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                                    <xs:annotation>
                                        <xs:documentation>The facetLabel's axes are added in the order specified, working from outside the chart to inside.</xs:documentation>
                                    </xs:annotation>
                                    <xs:element name="facetLevel">
                                        <xs:annotation>
                                            <xs:documentation>Controls the layout and style of the facets and provides a place for axes on facet dimensions to be defined.</xs:documentation>
                                        </xs:annotation>
                                        <xs:complexType>
                                            <xs:sequence minOccurs="0" maxOccurs="2">
                                                <xs:element ref="vis:axis"/>
                                            </xs:sequence>
                                            <xs:attribute name="id" type="xs:ID" >
                                                <xs:annotation>
                                                    <xs:documentation>The identifier for this item</xs:documentation>
                                                </xs:annotation>
                                            </xs:attribute>
                                            <xs:attribute name="level" type="xs:positiveInteger" use="required">
                                                <xs:annotation>
                                                    <xs:documentation>The level of the facting that this applies to. It is legal to define facetLabelings for levels that are not present in the chart, they will simply be ignored. Level 1 is the first dimension (the level in a simple paneled chart), level 2 is the next dimension in a 2-way table, etc.</xs:documentation>
                                                </xs:annotation>
                                            </xs:attribute>
                                            <xs:attribute name="gap" type="vis:length">
                                                <xs:annotation>
                                                    <xs:documentation>The total gap to leave between cells at this level. If both lowerGap and upperGap are specified, this value will be ignored. If expressed in absolute coordinates care must be taken to ensure the size is not larger than the size of the cell</xs:documentation>
                                                </xs:annotation>
                                            </xs:attribute>
                                            <xs:attribute name="lowerGap" type="vis:length">
                                                <xs:annotation>
                                                    <xs:documentation>The gap to leave at the left or top side of a cell at this level. If expressed in absolute coordinates care must be taken to ensure the total size is not larger than the size of the cell</xs:documentation>
                                                </xs:annotation>
                                            </xs:attribute>
                                            <xs:attribute name="upperGap" type="vis:length">
                                                <xs:annotation>
                                                    <xs:documentation>The gap to leave at the right or bottom side of a cell at this level. If expressed in absolute coordinates care must be taken to ensure the total size is not larger than the size of the cell</xs:documentation>
                                                </xs:annotation>
                                            </xs:attribute>
                                            <xs:attribute name="style" type="xs:IDREF">
                                                <xs:annotation>
                                                    <xs:documentation>Style for the cells at this level of faceting</xs:documentation>
                                                </xs:annotation>
                                            </xs:attribute>
                                            <xs:attribute name="zOrder" type="xs:int">
                                                <xs:annotation>
                                                    <xs:documentation>Integer which determines in what order things are drawn in.  If this is not specified things will draw in the order they are found in the specification.</xs:documentation>
                                                </xs:annotation>
                                            </xs:attribute>
                                        </xs:complexType>
                                    </xs:element>
                                </xs:sequence>
                                <xs:attribute name="cellAspect" type="xs:double">
                                    <xs:annotation>
                                        <xs:documentation>If set, forces each cell to be the given aspect ratio</xs:documentation>
                                    </xs:annotation>
                                </xs:attribute>
                                <xs:attribute name="topDown" type="xs:boolean">
                                    <xs:annotation>
                                        <xs:documentation>Denotes whether to require a layout to be top-down (table-like) as opposed to bottom-up (chart-like)</xs:documentation>
                                    </xs:annotation>
                                </xs:attribute>
                                <xs:attribute name="method">
                                    <xs:annotation>
                                        <xs:documentation>The overall method of laying out the cells</xs:documentation>
                                    </xs:annotation>
                                    <xs:simpleType>
                                        <xs:restriction base="xs:string">
                                            <xs:enumeration value="structured">
                                                <xs:annotation>
                                                    <xs:documentation>In a table-like format</xs:documentation>
                                                </xs:annotation>
                                            </xs:enumeration>
                                            <xs:enumeration value="unstructured">
                                                <xs:annotation>
                                                    <xs:documentation>As a sinlge long list, wrapped into the available space</xs:documentation>
                                                </xs:annotation>
                                            </xs:enumeration>
                                        </xs:restriction>
                                    </xs:simpleType>
                                </xs:attribute>
                                <xs:attribute name="id" type="xs:ID"/>
                            </xs:complexType>
                        </xs:element>
                        <xs:group ref="vis:element" minOccurs="0" maxOccurs="unbounded"/>
                        <xs:group ref="vis:guide" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                    <xs:attribute name="cellStyle" type="xs:IDREF">
                        <xs:annotation>
                            <xs:documentation>The style for the cell frame</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="coordinates">
        <xs:annotation>
            <xs:documentation>Defines the Coordinate system to be used for the graph. Elements will be placed within a coordiate system</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>The order of the dimensions determines which they refer to. The first dimension specified is 'X', the second 'Y', etc.</xs:documentation>
                </xs:annotation>
                <xs:element name="dimension">
                    <xs:annotation>
                        <xs:documentation>Defines a dimension of the coordinate system for locating items</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element ref="vis:scale" minOccurs="0"/>
                            <xs:element ref="vis:axis" minOccurs="0" maxOccurs="unbounded"/>
                        </xs:sequence>
                        <xs:attribute name="id" type="xs:ID">
                            <xs:annotation>
                                <xs:documentation>Identifier. This can be used from a coordinateSystem to identify the constituent dimensions</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="domain" type="xs:IDREF">
                            <xs:annotation>
                                <xs:documentation>The domain defines how data is mapped into this dimension. Data at the top of the domain are mapped to the maximum value on this dimension. Data at the lower end of the domain are mapped to the minimum value of the dimension</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="unionDomain" type="xs:boolean" default="false">
                            <xs:annotation>
                                <xs:documentation>If true, the domain specificed will be unioned with the default domain instead of overriding it</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="niceUpperMapping" type="xs:boolean">
                            <xs:annotation>
                                <xs:documentation>whether to modify the upper bound to  a nice round number or leave it exactly as defined by the domain</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="niceLowerMapping" type="xs:boolean">
                            <xs:annotation>
                                <xs:documentation>whether to modify the lower bound to  a nice round number or leave it exactly as defined by the domain</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="upperMargin" type="vis:length">
                            <xs:annotation>
                                <xs:documentation>Amount to extend past the domain to provide a margin at the top where data are not expected to map into</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="lowerMargin" type="vis:length">
                            <xs:annotation>
                                <xs:documentation>Amount to extend past the domain to provide a margin at the top where data are not expected to map into</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="clusterVariable" type="xs:IDREF">
                            <xs:annotation>
                                <xs:documentation>If defined, categories from this categorical variable will be used to subdivide up the dimension and provide clustering in this dimension</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="clusterGap" type="vis:length">
                            <xs:annotation>
                                <xs:documentation>The gap between clusters</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                    </xs:complexType>
                </xs:element>
                <xs:element name="dimensionReference">
                    <xs:annotation>
                        <xs:documentation>Refers to a dimension in a different coordinate system. This means that a dimension is effectively shared across coordinate systems</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:attribute name="ref" type="xs:IDREF" use="required">
                            <xs:annotation>
                                <xs:documentation>The dimension to reference</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                    </xs:complexType>
                </xs:element>
                <xs:element name="reflectionTransform">
                    <xs:annotation>
                        <xs:documentation>A coordinate transform that reflects around a dimension</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:attribute name="id" type="xs:ID"/>
                        <xs:attribute name="dimension">
                            <xs:annotation>
                                <xs:documentation>The dimension in which to reflect</xs:documentation>
                            </xs:annotation>
                            <xs:simpleType>
                                <xs:restriction base="xs:string">
                                    <xs:enumeration value="x"/>
                                    <xs:enumeration value="y"/>
                                    <xs:enumeration value="z"/>
                                </xs:restriction>
                            </xs:simpleType>
                        </xs:attribute>
                        <xs:attribute name="alternating" type="xs:boolean">
                            <xs:annotation>
                                <xs:documentation>Whether reflection should alternate between facet faces.</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                    </xs:complexType>
                </xs:element>
                <xs:element name="obliqueTransform">
                    <xs:annotation>
                        <xs:documentation>A coordinate transform for 3D that performs an oblique projection</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:attribute name="theta" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>Angle to project at </xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="distance" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>Distance from the viewer. '1' is normal and values in the range 0.2 .. 3 are useful</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="foreShortening" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>How deep the projection extends. '1' is normal, '0' means no extension</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="xscale" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>Multiplier for distorting x dimension</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="yscale" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>Multiplier for distorting ydimension</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="dx" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>Offset the projection in the x dimension. Useful values are in the range 0 to 1</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="dy" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>Offset the projection in the y dimension. Useful values are in the range 0 to 1</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="id" type="xs:ID"/>
                    </xs:complexType>
                </xs:element>
                <xs:element name="rectangularTransform">
                    <xs:annotation>
                        <xs:documentation>A coordinate transform for 3D that performs a viewpoint change</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:attribute name="theta" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>Angle to rotate around 'x' axis </xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="phi" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>Angle to rotate around 'y' axis</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="zeta" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>Angle to rotate around 'z' axis</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="distance" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>Distance from the viewer. '1' is normal and values in the range 0.2 .. 3 are useful</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="projectionDistance" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>Distance to infinity (where all lines converge). Provides parallax effect if less than infinity</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="xscale" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>Multiplier for distorting x dimension</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="yscale" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>Multiplier for distorting y dimension</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="zscale" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>Multiplier for distorting z dimension</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="dx" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>Offset the projection in the x dimension. Useful values are in the range 0 to 1</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="dy" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>Offset the projection in the y dimension. Useful values are in the range 0 to 1</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="id" type="xs:ID"/>
                    </xs:complexType>
                </xs:element>
                <xs:element name="mapProjection">
                    <xs:annotation>
                        <xs:documentation>Treates the data as latitide / longitude and projects according to a transformation</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:attribute name="type">
                            <xs:annotation>
                                <xs:documentation>Method to use to project</xs:documentation>
                            </xs:annotation>
                            <xs:simpleType>
                                <xs:restriction base="xs:string">
                                    <xs:enumeration value="lambert"/>
                                    <xs:enumeration value="mercator"/>
                                    <xs:enumeration value="transverseMercator"/>
                                </xs:restriction>
                            </xs:simpleType>
                        </xs:attribute>
                        <xs:attribute name="id" type="xs:ID"/>
                    </xs:complexType>
                </xs:element>
                <xs:element name="fishEyeTransform">
                    <xs:annotation>
                        <xs:documentation>Magnifies a local area in a radial fashion</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:attribute name="magnification" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>Magnification factor</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="radius" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>radius to magnify; on a 0 to 1 scale</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="x" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>x location of the center of magnification</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="y" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>y location of the center of magnification</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="id" type="xs:ID"/>
                    </xs:complexType>
                </xs:element>
                <xs:element name="functionalTransform">
                    <xs:annotation>
                        <xs:documentation>Transforms a single dimension based on a specified function</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:attribute name="dimension">
                            <xs:annotation>
                                <xs:documentation>dimension to tranform</xs:documentation>
                            </xs:annotation>
                            <xs:simpleType>
                                <xs:restriction base="xs:string">
                                    <xs:enumeration value="x"/>
                                    <xs:enumeration value="y"/>
                                    <xs:enumeration value="z"/>
                                </xs:restriction>
                            </xs:simpleType>
                        </xs:attribute>
                        <xs:attribute name="method">
                            <xs:annotation>
                                <xs:documentation>Method to use</xs:documentation>
                            </xs:annotation>
                            <xs:simpleType>
                                <xs:restriction base="xs:string">
                                    <xs:enumeration value="cosine"/>
                                    <xs:enumeration value="log"/>
                                    <xs:enumeration value="power"/>
                                </xs:restriction>
                            </xs:simpleType>
                        </xs:attribute>
                        <xs:attribute name="base" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>base or exponent to use for the appropriate method</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="id" type="xs:ID"/>
                    </xs:complexType>
                </xs:element>
                <xs:element name="insetTransform">
                    <xs:annotation>
                        <xs:documentation>Insets the coordinates for each dimension</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:attribute name="x-min" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>amount to inset the x dimension's minimum value. 0 to 1 is the useful range</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="y-min" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>amount to inset the y dimension's minimum value. 0 to 1 is the useful range</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="z-min" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>amount to inset the z dimension's minimum value. 0 to 1 is the useful range</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="x-max" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>amount to inset the x dimension's maximum value. 0 to 1 is the useful range</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="y-max" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>amount to inset the y dimension's maximum value. 0 to 1 is the useful range</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="z-max" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>amount to inset the z dimension's maximum value. 0 to 1 is the useful range</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="id" type="xs:ID">
                            <xs:annotation>
                                <xs:documentation>The identifier for this item</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                    </xs:complexType>
                </xs:element>
                <xs:element name="polarTransform">
                    <xs:annotation>
                        <xs:documentation>Converts the first two dimensions to polar coordinates</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:attribute name="id" type="xs:ID"/>
                        <xs:attribute name="startAngle" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>Angle to start at relative to the positive horizontal axis</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="cycles" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>how many cycles to wrap around. Defaults to 1</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="counterClockwise" type="xs:boolean">
                            <xs:annotation>
                                <xs:documentation>If true, direction is counter-clockwise</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="preserveStraightLines" type="xs:boolean">
                            <xs:annotation>
                                <xs:documentation>if true, lines are not curved within the space, but drawn straight from defined point to defined poiint</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                    </xs:complexType>
                </xs:element>
                <xs:element name="sameRatioTransform">
                    <xs:annotation>
                        <xs:documentation>A transformation that preserves the ratio of data units to screen pixels between the first two dimensions</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:attribute name="center" type="xs:boolean">
                            <xs:annotation>
                                <xs:documentation>When there is extra space on the chart as a result of the projection, center the projection</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="id" type="xs:ID"/>
                    </xs:complexType>
                </xs:element>
                <xs:element name="transposeTransform">
                    <xs:annotation>
                        <xs:documentation>A coordinate transform that transposes the first two dimensions</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:attribute name="id" type="xs:ID"/>
                    </xs:complexType>
                </xs:element>
                <xs:element name="parallelCoordinatesTransform">
                    <xs:annotation>
                        <xs:documentation>A coordinate transform that implement parallel coordinates; reducing many dimensions to two</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:attribute name="id" type="xs:ID"/>
                    </xs:complexType>
                </xs:element>
                <xs:element name="aspectRatioTransform">
                    <xs:annotation>
                        <xs:documentation>A transformation that preserves the ratio of data units to screen pixels between the first two dimensions</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:attribute name="aspect" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>The aspect ratio between Y and X</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="id" type="xs:ID"/>
                    </xs:complexType>
                </xs:element>
            </xs:choice>
            <xs:attribute name="id" type="xs:ID" >
                <xs:annotation>
                    <xs:documentation>Identifier for the coordinate system</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="axis">
        <xs:annotation>
            <xs:documentation>Defines a visual representation of a dimension</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="vis:label" minOccurs="0"/>
                <xs:sequence minOccurs="0">
                    <xs:element ref="vis:majorTicks"/>
                    <xs:element ref="vis:minorTicks" minOccurs="0"/>
                </xs:sequence>
                <xs:element name="axisTransformParameter" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation>
                        <xs:documentation>Parameters to be used by axis transformations.</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:attribute name="id" type="xs:ID">
                            <xs:annotation>
                                <xs:documentation>Identifier for the axis</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="parameterName" type="xs:string"/>
                        <xs:attribute name="parameterValue"/>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>
            <xs:attribute name="id" type="xs:ID" >
                <xs:annotation>
                    <xs:documentation>Identifier for the axis</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="style" type="xs:IDREF">
                <xs:annotation>
                    <xs:documentation>The style for drawing the base line of the axis</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="opposite" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation>Axes are drawn in the most suitable position, for example, to the left of or below a simple rectangular plot. If this is set to true, they will be drawn opposite their preferred position</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="transform">
                <xs:annotation>
                    <xs:documentation>Apply a transform to the ticks for the axis.</xs:documentation>
                </xs:annotation>
                <xs:simpleType>
                    <xs:restriction base="xs:string">
                        <xs:enumeration value="linear"/>
                        <xs:enumeration value="percent"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="maxSize" type="vis:length">
                <xs:annotation>
                    <xs:documentation>An axis takes up part of the frame. It is sized dynamically to balance display requirements. By default it can take up no more than a given fraction of a display (this fraction may vary by situation). Setting this value allows an axis to use up to a given fraction of screen space</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="repeat">
                <xs:annotation>
                    <xs:documentation>Whether to add an axis on each cell in a faceting</xs:documentation>
                </xs:annotation>
                <xs:simpleType>
                    <xs:restriction base="xs:NMTOKEN">
                        <xs:enumeration value="never">
                            <xs:annotation>
                                <xs:documentation>Never repeat the axes</xs:documentation>
                            </xs:annotation>
                        </xs:enumeration>
                        <xs:enumeration value="always">
                            <xs:annotation>
                                <xs:documentation>Always repeat the axes</xs:documentation>
                            </xs:annotation>
                        </xs:enumeration>
                    </xs:restriction>
                </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="combineAxisLabels" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation>If true, all axis labels of a given label will be combined into a single axis label.  If false, they are repeated on a per-row or per-column basis.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="zOrder" type="xs:int">
                <xs:annotation>
                    <xs:documentation>Integer which determines in what order things are drawn in.  If this is not specified things will draw in the order they are found in the specification.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="majorTicks">
        <xs:annotation>
            <xs:documentation>Tick marks for an axis</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:ticksType">
                    <xs:choice minOccurs="0">
                        <xs:element ref="vis:label" minOccurs="0"/>
                        <xs:group ref="vis:format"/>
                    </xs:choice>
                    <xs:attribute name="style" type="xs:IDREF">
                        <xs:annotation>
                            <xs:documentation>The style for each of the tick labels</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="tickFrameStyle" type="xs:IDREF">
                        <xs:annotation>
                            <xs:documentation>The style for each of the tick label's frames</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="labelAngle">
                        <xs:annotation>
                            <xs:documentation>An angle in degrees between 0 and 360 specifying at what angle the labels for the ticks should be drawn. Zero is horizontal. If left undefined a suitable angle is chosen so as to make the axis as legible as possible in as compact a space as possible.</xs:documentation>
                        </xs:annotation>
                        <xs:simpleType>
                            <xs:restriction base="xs:double">
                                <xs:minInclusive value="-360"/>
                                <xs:maxInclusive value="360"/>
                            </xs:restriction>
                        </xs:simpleType>
                    </xs:attribute>
                    <xs:attribute name="stagger" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>If true, a staggered pattern will be applied, with every second label placed a line lower than usual, so that longer labels can be drawn without occlusion. Tick marks are extended so they connect to the staggered labels. If undefined stagger may be chosen if it is the best way to make the axis legible and compact.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="labelFrequency" type="xs:positiveInteger">
                        <xs:annotation>
                            <xs:documentation>If set greater than 1, labels will be skipped so as to show every n'th label, where n is the value of this parameter.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="delta" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>The increment between two tickmarks, expresed in the units of the data itself. For date data, the deltaUnit defines what units to use</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="deltaUnit">
                        <xs:annotation>
                            <xs:documentation>For date scales, determines what the units for the delta will be</xs:documentation>
                        </xs:annotation>
                        <xs:simpleType>
                            <xs:restriction base="xs:string">
                                <xs:enumeration value="second"/>
                                <xs:enumeration value="minute"/>
                                <xs:enumeration value="hour"/>
                                <xs:enumeration value="day"/>
                                <xs:enumeration value="week"/>
                                <xs:enumeration value="month"/>
                                <xs:enumeration value="year"/>
                            </xs:restriction>
                        </xs:simpleType>
                    </xs:attribute>
                    <xs:attribute name="base" type="vis:dateOrNumber" default="0">
                        <xs:annotation>
                            <xs:documentation>A value at which a tick mark is desired. Ticks will start at this value and then be placed above and below this value at integral increments of the delta value (which will be chosen automatically if not specified). Only ticks lying within the axes bounds will be displayed. It is legal for this value to be outside the axis range. For example, if the axis range is [7,23] and delta is 4, a base of 1 will place ticks at 9, 13, 17, 21</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="minorTicks">
        <xs:annotation>
            <xs:documentation>Minor tick marks for an axis</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:ticksType">
                    <xs:attribute name="number" type="xs:positiveInteger">
                        <xs:annotation>
                            <xs:documentation>The number of minor ticks per major tick division</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="color">
        <xs:annotation>
            <xs:documentation>Maps a variable to the color of a graphic item. The color includes all components of the color (hue, saturation, brightness,transparency), so if used with those aesthetics, this one should come first in the list</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:aesthetic">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:element ref="vis:colorMapping" minOccurs="0"/>
                    </xs:sequence>
                    <xs:attribute name="affect" type="vis:colorAffectType" default="fill">
                        <xs:annotation>
                            <xs:documentation>Type of color affected.  Fill colors are for the interior of a drawn object while a stroke color is for the edge of the drawn object.  Note that some objects, such as lines do not have an interior.  "main" is usually a fill color. "secondary" is usually a stroke color. "both" affects both. "fill" is explicitly a fill color.  "main" or "secondary" should be used in preference.  "stroke" is explicitly a stroke color.  "main" or "secondary" should be used in preference.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="cycle" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>The cycle of colors that will be applied to categorical data.  The colors will be applied in order to the resulting order of categories.  After the last category is reached, the colors will cycle to the beginning of the array.  This should be in the format of ":" delimited list of colors.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="offset">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:aesthetic">
                    <xs:attribute name="low" type="xs:string"/>
                    <xs:attribute name="high" type="xs:string"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="pattern">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:aesthetic">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:element ref="vis:integerMapping" minOccurs="0"/>
                    </xs:sequence>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="labeling">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:aesthetic">
                    <xs:sequence>
                        <xs:choice minOccurs="0">
                            <xs:group ref="vis:format"/>
                        </xs:choice>
                        <xs:choice minOccurs="0" maxOccurs="unbounded">
                            <xs:element ref="vis:styleBy"/>
                            <xs:element ref="vis:size"/>
                            <xs:element ref="vis:color"/>
                            <xs:element ref="vis:colorComponent"/>
                            <xs:element ref="vis:transparency"/>
                            <xs:element ref="vis:rotation"/>
                            <xs:element ref="vis:labelLocation"/>
                        </xs:choice>
                    </xs:sequence>
                    <xs:attribute name="style" type="xs:IDREF">
                        <xs:annotation>
                            <xs:documentation>The style for the text of the labeling.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textFrameStyle" type="xs:IDREF">
                        <xs:annotation>
                            <xs:documentation>The style for the plaque surrounding the text of the labeling.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="connectingLines" type="xs:boolean" default="false"/>
                    <xs:attribute name="minConnectingLineLength" type="vis:length"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="colorComponent">
        <xs:annotation>
            <xs:documentation>Maps a variable to the color of a graphic item. The color includes all components of the color (hue, saturation, brightness,transparency), so if used with those aesthetics, this one should come first in the list</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:aesthetic">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:element ref="vis:doubleMapping" minOccurs="0"/>
                    </xs:sequence>
                    <xs:attribute name="low">
                        <xs:annotation>
                            <xs:documentation>The minimum value for the color component.</xs:documentation>
                        </xs:annotation>
                        <xs:simpleType>
                            <xs:restriction base="xs:double">
                                <xs:minInclusive value="0"/>
                                <xs:maxInclusive value="1"/>
                            </xs:restriction>
                        </xs:simpleType>
                    </xs:attribute>
                    <xs:attribute name="high">
                        <xs:annotation>
                            <xs:documentation>The maximum value for the color component.</xs:documentation>
                        </xs:annotation>
                        <xs:simpleType>
                            <xs:restriction base="xs:double">
                                <xs:minInclusive value="0"/>
                                <xs:maxInclusive value="1"/>
                            </xs:restriction>
                        </xs:simpleType>
                    </xs:attribute>
                    <xs:attribute name="type" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>Which color component.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="affect" type="vis:colorAffectType" default="fill">
                        <xs:annotation>
                            <xs:documentation>Type of color affected.  Fill colors are for the interior of a drawn object while a stroke color is for the edge of the drawn object.  Note that some objects, such as lines do not have an interior.  "main" is usually a fill color. "secondary" is usually a stroke color. "both" affects both. "fill" is explicitly a fill color.  "main" or "secondary" should be used in preference.  "stroke" is explicitly a stroke color.  "main" or "secondary" should be used in preference.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="dateTimeFormat">
        <xs:annotation>
            <xs:documentation>Defines the format of a date/time value. The format consists of numerous options for representation of dates. If an option is undefined, the locale defines whether or not to set it, so the most appropriate value is chosen based on the locale. All options modify this default behavior.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:formatType">
                    <xs:attribute name="baseFormat" use="required">
                        <xs:annotation>
                            <xs:documentation>This defines the base format. A dateTime may be just a date, just a time, or may be both. Default values of all fields will be chosen based on the locale and on the value of this field</xs:documentation>
                        </xs:annotation>
                        <xs:simpleType>
                            <xs:restriction base="xs:string">
                                <xs:enumeration value="date"/>
                                <xs:enumeration value="time"/>
                                <xs:enumeration value="dateTime"/>
                            </xs:restriction>
                        </xs:simpleType>
                    </xs:attribute>
                    <xs:attribute name="dayOfMonthPadding" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>If true, this field will be padded</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="weekPadding" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>If true, this field will be padded</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="dayPadding" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>If true, day field will be padded</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="hourPadding" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>If true, this field will be padded</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="minutePadding" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>If true, this field will be padded</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="secondPadding" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>If true, this field will be padded</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="showEra" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>Whether or not to show this time field</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="showYear" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>Whether or not to show this time field</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="showQuarter" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>Whether or not to show this time field</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="showMonth" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>Whether or not to show this time field</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="showWeek" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>Whether or not to show this time field</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="showDay" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>Whether or not to show this time field</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="showHour" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>Whether or not to show this time field</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="showMinute" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>Whether or not to show this time field</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="showSecond" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>Whether or not to show this time field</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="showMillis" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>Whether or not to show this time field</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="dayOfWeekAbbreviation" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>Whether or not to abbreviate the day of the week</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="yearAbbreviation" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>Whether or not to abbreviate the year (drop century or not)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="quarterPrefix" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>Add a prefix for the quarter (e.g. 'Q' to get Q1, Q2, Q3, Q4)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="quarterSuffix" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>Add a suffixfor the quarter (e.g. 'q' to get 1q, 2q, 3q, 4q)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="dayType">
                        <xs:annotation>
                            <xs:documentation>Whether to show the day as day within month or day within year</xs:documentation>
                        </xs:annotation>
                        <xs:simpleType>
                            <xs:restriction base="xs:string">
                                <xs:enumeration value="month"/>
                                <xs:enumeration value="year"/>
                            </xs:restriction>
                        </xs:simpleType>
                    </xs:attribute>
                    <xs:attribute name="hourFormat">
                        <xs:annotation>
                            <xs:documentation>Choice of hour display method, in am/pm style (1pm), 24-hour style (13) or 12-hour style (1)</xs:documentation>
                        </xs:annotation>
                        <xs:simpleType>
                            <xs:restriction base="xs:string">
                                <xs:enumeration value="AMPM"/>
                                <xs:enumeration value="AS_24"/>
                                <xs:enumeration value="AS_12"/>
                            </xs:restriction>
                        </xs:simpleType>
                    </xs:attribute>
                    <xs:attribute name="monthFormat">
                        <xs:annotation>
                            <xs:documentation>Format for the month; shortMar), long (March), number (3), or paddedNumbed (03)</xs:documentation>
                        </xs:annotation>
                        <xs:simpleType>
                            <xs:restriction base="xs:string">
                                <xs:enumeration value="short"/>
                                <xs:enumeration value="long"/>
                                <xs:enumeration value="number"/>
                                <xs:enumeration value="paddedNumber"/>
                            </xs:restriction>
                        </xs:simpleType>
                    </xs:attribute>
                    <xs:attribute name="showDayOfWeek" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>Whether or not days of the week will be shown.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="point" type="vis:elementType">
        <xs:annotation>
            <xs:documentation>A point element</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="line">
        <xs:annotation>
            <xs:documentation>A line element</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:elementType">
                    <xs:attribute name="breakRepresentation" type="vis:breakRepresentationType"/>
                    <xs:attribute name="showDiscontinuity" type="xs:boolean"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="interval">
        <xs:annotation>
            <xs:documentation>An interval element</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:elementType">
                    <xs:attribute name="centerIn3D" type="xs:boolean"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="polygon" type="vis:elementType">
        <xs:annotation>
            <xs:documentation>A polygonal element</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="area">
        <xs:annotation>
            <xs:documentation>An area element</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:elementType">
                    <xs:attribute name="breakRepresentation" type="vis:breakRepresentationType"/>
                    <xs:attribute name="showDiscontinuity" type="xs:boolean"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="schema">
        <xs:annotation>
            <xs:documentation>A schema element</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:elementType">
                    <xs:attribute name="medianStyle" type="xs:IDREF"/>
                    <xs:attribute name="fenceStyle" type="xs:IDREF"/>
                    <xs:attribute name="hingeStyle" type="xs:IDREF"/>
                    <xs:attribute name="outlierStyle" type="xs:IDREF"/>
                    <xs:attribute name="extremeStyle" type="xs:IDREF"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="link" type="vis:elementType">
        <xs:annotation>
            <xs:documentation>A link element</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="path">
        <xs:annotation>
            <xs:documentation>A path element</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:elementType">
                    <xs:attribute name="breakRepresentation" type="vis:breakRepresentationType"/>
                    <xs:attribute name="showDiscontinuity" type="xs:boolean"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="conditionalStyle">
        <xs:annotation>
            <xs:documentation>Applies a style to an element for certain facets only</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:string"/>
            <xs:attribute name="when" type="xs:string" use="required">
                <xs:annotation>
                    <xs:documentation>A boolean expression using facets that determines when the style is applied. Examples are "facet1 != facet2" or "facet1 == 2"</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="style" type="xs:IDREF" use="required">
                <xs:annotation>
                    <xs:documentation>Style to apply when the expression evaluates to true</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="gridline">
        <xs:annotation>
            <xs:documentation>Grid lines will be displayed from tick mark locations for this set of ticks</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="vis:conditionalStyle" minOccurs="0"/>
                <xs:element ref="vis:styleReference" minOccurs="0"/>
            </xs:sequence>
            <xs:attribute name="id" type="xs:ID"/>
            <xs:attribute name="style" type="xs:IDREF"/>
            <xs:attribute name="zOrder" type="xs:int">
                <xs:annotation>
                    <xs:documentation>Integer which determines in what order things are drawn in.  If this is not specified things will draw in the order they are found in the specification.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="elapsedTimeFormat">
        <xs:annotation>
            <xs:documentation>Defines the output format of elapsed time. Formating elapsed time happens in 3 steps.
            1) The calendar computes the elapsed time from the start time and another time.
            2) The components of the elapsed time are formatted using the NumberFormatSpecication if provided.
            3) The output is assembled using the output template and returned as a String.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:formatType">
                    <xs:attribute name="maximumFractionDigits" type="xs:nonNegativeInteger">
                        <xs:annotation>
                            <xs:documentation>maximum number of digits to display in the fractional part of a decimal or
 scientific representation</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="startTime" type="vis:date">
                        <xs:annotation>
                            <xs:documentation>Sets the start time (aka "base", "zero time") to calculate elapsed time from.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="padTime" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>Whether to pad the time components (hours, minutes, seconds) with zeros or not</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="pattern" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>Sets the pattern for formating the elapsed time. The supported tokens are
     yyyy years
     MM months
     dd days
     HH hours
     mm minutes
     ss seconds

     The tokens must be exactly as defined above.

     ie cannot use H, h, hh, k, kk, K or KK for hours.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="numberFormat">
        <xs:annotation>
            <xs:documentation>Specification of how a number is to be formatted</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:formatType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:documentation>When applying the scalingFactors in this sequence, the scaling factor that produces the smallest non-zero integer part is used</xs:documentation>
                        </xs:annotation>
                        <xs:element name="unitRule">
                            <xs:annotation>
                                <xs:documentation>Specifies a rule to be used to abbreviate a number. When such a rule is applied, it overrides the numberFormat's scaling factor and replaces its suffix and prefix if defined in the rule - otherwise the suffix and prefix are left alone</xs:documentation>
                            </xs:annotation>
                            <xs:complexType>
                                <xs:attribute name="factor" type="xs:double" use="required">
                                    <xs:annotation>
                                        <xs:documentation>The strictly positive value used to scale the number to be formatted. This rule may only be applied if the result has a non-zero integer part</xs:documentation>
                                    </xs:annotation>
                                </xs:attribute>
                                <xs:attribute name="prefix" type="xs:string">
                                    <xs:annotation>
                                        <xs:documentation>When this rule is applied, this string replaces the numberFormat's prefix</xs:documentation>
                                    </xs:annotation>
                                </xs:attribute>
                                <xs:attribute name="suffix" type="xs:string">
                                    <xs:annotation>
                                        <xs:documentation>When this rule is applied, this string replaces the numberFormat's suffix</xs:documentation>
                                    </xs:annotation>
                                </xs:attribute>
                                <xs:attribute name="id" type="xs:ID"/>
                            </xs:complexType>
                        </xs:element>
                    </xs:sequence>
                    <xs:attribute name="scientific" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>Whether to use scientific notation</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="minimumFractionDigits" type="xs:nonNegativeInteger">
                        <xs:annotation>
                            <xs:documentation>minimum number of digits to display in the fractional part of a decimal or scientific representation</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="maximumFractionDigits" type="xs:nonNegativeInteger">
                        <xs:annotation>
                            <xs:documentation>maximum number of digits to display in the fractional part of a decimal or scientific representation</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="minimumIntegerDigits" type="xs:nonNegativeInteger">
                        <xs:annotation>
                            <xs:documentation>minimum number of digits to display in the integer part of a decimal  representation. </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="maximumIntegerDigits" type="xs:nonNegativeInteger">
                        <xs:annotation>
                            <xs:documentation>maximum number of digits to display in the integer part of a decimal  representation. </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="useGrouping" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>If true, grouping characters will be inserted for large integer values, so that 1000000 would be shown as 1,000,000</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="hideNegatives" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>If true, negative values are shown as their absolute value instead</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="negativesOutside" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>If true, negative sign or parentheses will be shown outside the prefix / suffix</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="scalingFactor" type="xs:double">
                        <xs:annotation>
                            <xs:documentation>A number which will be divided into the data before formatting. A typical use would be to specify scalingFactor="1000000" and suffix="millions" or scalingFactor="0.001" and suffix="millis"</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="negativesInParentheses" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>If true, negative values will be indicated by parentheses rather than the negative sign</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="relabel">
        <xs:annotation>
            <xs:documentation>For display purposes only, maps a value of the variable into a new display value</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID"/>
            <xs:attribute name="from" type="xs:string" use="required">
                <xs:annotation>
                    <xs:documentation>Real data value. </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="to" type="xs:string" use="required">
                <xs:annotation>
                    <xs:documentation>Label to be used for display instead of the real value</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="rotation">
        <xs:annotation>
            <xs:documentation>Maps a variable to an angle at which to rotate a symbol</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:aesthetic">
                    <xs:attribute name="low" default="0">
                        <xs:annotation>
                            <xs:documentation>The lowest value in the domain of the variable will be mapped to this angle</xs:documentation>
                        </xs:annotation>
                        <xs:simpleType>
                            <xs:restriction base="xs:double">
                                <xs:minInclusive value="0"/>
                                <xs:maxInclusive value="360"/>
                            </xs:restriction>
                        </xs:simpleType>
                    </xs:attribute>
                    <xs:attribute name="high" default="360">
                        <xs:annotation>
                            <xs:documentation>The maximum value in the domain of the variable will be mapped to this angle</xs:documentation>
                        </xs:annotation>
                        <xs:simpleType>
                            <xs:restriction base="xs:double">
                                <xs:minInclusive value="0"/>
                                <xs:maxInclusive value="360"/>
                            </xs:restriction>
                        </xs:simpleType>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="scale">
        <xs:annotation>
            <xs:documentation>A transform of the data to re-scale it using a specified method</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID"/>
            <xs:attribute name="method" use="required">
                <xs:annotation>
                    <xs:documentation>What sort of transformation to perform</xs:documentation>
                </xs:annotation>
                <xs:simpleType>
                    <xs:restriction base="xs:string">
                        <xs:enumeration value="linear">
                            <xs:annotation>
                                <xs:documentation>Simple linear scale</xs:documentation>
                            </xs:annotation>
                        </xs:enumeration>
                        <xs:enumeration value="log">
                            <xs:annotation>
                                <xs:documentation>Log scale, ticks look like: 1, 10, 100, 1000, .... A numeric parameter "base" may be used to change the base from the default "10"</xs:documentation>
                            </xs:annotation>
                        </xs:enumeration>
                        <xs:enumeration value="power">
                            <xs:annotation>
                                <xs:documentation>A power scale. The exponent should be set in a paramter to a positive value. </xs:documentation>
                            </xs:annotation>
                        </xs:enumeration>
                        <xs:enumeration value="log.safe">
                            <xs:annotation>
                                <xs:documentation>A transformation  y = SIGN(x) LOG( 1 + ABS(x)) which is defined for all values of x, maps 0 to 0 and preserves the sign of the original data</xs:documentation>
                            </xs:annotation>
                        </xs:enumeration>
                        <xs:enumeration value="power.safe">
                            <xs:annotation>
                                <xs:documentation>A transformation  y = SIGN(x) POWER(ABS(x), EXPONENT) which is defined for all values of x, maps 0 to 0 and preserves the sign of the original data</xs:documentation>
                            </xs:annotation>
                        </xs:enumeration>
                    </xs:restriction>
                </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="invert" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation>Whether to invert the scale so it runs, for example, right to left instead of left to right.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="origin" type="xs:string">
                <xs:annotation>
                    <xs:documentation>The origin of a scale. This is particularly important to define for dates which do not have good default date origins</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="base" type="xs:double">
                <xs:annotation>
                    <xs:documentation>The base for a log transform or the exponent for a power transform</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="size">
        <xs:annotation>
            <xs:documentation>Maps a variable to the size of the graphic item</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:aesthetic">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:element ref="vis:lengthMapping" minOccurs="0"/>
                    </xs:sequence>
                    <xs:attributeGroup ref="vis:aestheticRangeLengths"/>
                    <xs:attribute name="type" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>In which way size is varied</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="stringFormat">
        <xs:annotation>
            <xs:documentation>A format for a string value</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:formatType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:element ref="vis:relabel"/>
                    </xs:sequence>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="style">
        <xs:annotation>
            <xs:documentation>A Cascading style sheet - like definition of a style to be used to control drawing details such as colors, line widths, fonts, pattern and transparency</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="vis:style" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="vis:extension" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="id" type="xs:ID" />
            <xs:attribute name="gradient-method" type="xs:string"/>
            <xs:attribute name="gradient-color" type="xs:string"/>
            <xs:attribute name="gradient-focus" type="xs:string"/>
            <xs:attribute name="gradient-angle" type="xs:string"/>
            <xs:attribute name="gradient-size" type="xs:string"/>
            <xs:attribute name="gradient-opacity" type="xs:string"/>
            <xs:attribute name="gradient-isInverted" type="xs:string"/>
            <xs:attribute name="shadow-color" type="xs:string"/>
            <xs:attribute name="shadow-opacity" type="xs:string"/>
            <xs:attribute name="shadow-dx" type="xs:string"/>
            <xs:attribute name="shadow-dy" type="xs:string"/>
            <xs:attribute name="glyph-angle" type="xs:string"/>
            <xs:attribute name="glyph-aspect" type="xs:string"/>
            <xs:attribute name="color2" type="xs:string"/>
            <xs:attribute name="opacity2" type="xs:string"/>
            <xs:attribute name="pattern" type="xs:string"/>
            <xs:attribute name="background-method" type="xs:string"/>
            <xs:attribute name="background-image" type="xs:string"/>
            <xs:attribute name="margin-left" type="xs:string"/>
            <xs:attribute name="margin-right" type="xs:string"/>
            <xs:attribute name="margin-top" type="xs:string"/>
            <xs:attribute name="margin-bottom" type="xs:string"/>
            <xs:attribute name="margin" type="xs:string"/>
            <xs:attribute name="padding-left" type="xs:string"/>
            <xs:attribute name="padding-right" type="xs:string"/>
            <xs:attribute name="padding-top" type="xs:string"/>
            <xs:attribute name="padding-bottom" type="xs:string"/>
            <xs:attribute name="padding" type="xs:string"/>
            <xs:attribute name="color" type="xs:string"/>
            <xs:attribute name="opacity" type="xs:string"/>
            <xs:attribute name="stroke-dasharray" type="xs:string"/>
            <xs:attribute name="stroke-width" type="xs:string"/>
            <xs:attribute name="stroke-decoration" type="xs:string"/>
            <xs:attribute name="size" type="xs:string"/>
            <xs:attribute name="symbol" type="xs:string"/>
            <xs:attribute name="font-family" type="xs:string"/>
            <xs:attribute name="font-size" type="xs:string"/>
            <xs:attribute name="font-style" type="xs:string"/>
            <xs:attribute name="font-weight" type="xs:string"/>
            <xs:attribute name="bevel-size" type="xs:string"/>
            <xs:attribute name="depth" type="xs:string"/>
            <xs:attribute name="depthRelativeToWidth" type="xs:string"/>
            <xs:attribute name="lineMissingValuesOption" type="xs:string"/>
            <xs:attribute name="lineDrawingOption" type="xs:string"/>
            <xs:attribute name="stroke-linecap" type="xs:string"/>
            <xs:attribute name="labelAngle" type="xs:string"/>
            <xs:attribute name="labelInside" type="xs:string"/>
            <xs:attribute name="labelLocationHorizontal" type="xs:string"/>
            <xs:attribute name="labelLocationVertical" type="xs:string"/>
            <xs:attribute name="textAlignment" type="xs:string"/>
            <xs:attribute name="ignoreNewLines" type="xs:boolean"/>
            <xs:attribute name="twoCharacterVertical" type="xs:boolean"/>
            <xs:attribute name="baselineRotated" type="xs:boolean"/>
            <xs:attribute name="maxAttachedTextWidth" type="vis:length"/>
            <xs:attribute name="maxAttachedTextHeight" type="vis:length"/>
            <xs:attribute name="visible" type="xs:string"/>
            <xs:attribute name="width" type="xs:string"/>
            <xs:attribute name="text-fit" type="xs:string"/>
            <xs:attribute name="glyph-sides" type="xs:string"/>
            <xs:attribute name="fill" type="xs:string"/>
            <xs:attribute name="stroke" type="xs:string"/>
            <xs:attribute name="fill-opacity" type="xs:string"/>
            <xs:attribute name="stroke-opacity" type="xs:string"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="dash">
        <xs:annotation>
            <xs:documentation>A mapping from a categorical variable to a set of dash styles</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:aesthetic">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:element ref="vis:dashMapping" minOccurs="0"/>
                    </xs:sequence>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="shape">
        <xs:annotation>
            <xs:documentation>A mapping from a categorical variable to a set of glyph shapes</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:aesthetic">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:element ref="vis:symbolMapping" minOccurs="0"/>
                    </xs:sequence>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="labelLocation">
        <xs:annotation>
            <xs:documentation>If specified, determines the location along one dimension of a labeling within the data area.  The variable is used to map into continuous space based on the domain.  The intent of this feature is to allow labels to be dragged anywhere in the data display area</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:aesthetic">
                    <xs:attribute name="role">
                        <xs:annotation>
                            <xs:documentation>The dimension to map a variable to</xs:documentation>
                        </xs:annotation>
                        <xs:simpleType>
                            <xs:restriction base="xs:NMTOKEN">
                                <xs:pattern value="x"/>
                                <xs:pattern value="y"/>
                            </xs:restriction>
                        </xs:simpleType>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="styleBy">
        <xs:annotation>
            <xs:documentation>A mapping from a categorical variable to a set of discrete styles for graphic items</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:aesthetic">
                    <xs:attribute name="styleCycle" type="xs:IDREF">
                        <xs:annotation>
                            <xs:documentation>A cycle of styles to be used for categories of data. If undefined a default cycle will be used which is chosen based on the type of element being displayed.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="affects" type="xs:NMTOKEN">
                        <xs:annotation>
                            <xs:documentation>The name of the style attribute to be affected by the styleBy.  If not specified, the main style will be affected.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="transparency">
        <xs:annotation>
            <xs:documentation>Maps a variable to the transparency (1-opacity) of the graphic item</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:aesthetic">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:element ref="vis:doubleMapping" minOccurs="0"/>
                    </xs:sequence>
                    <xs:attributeGroup ref="vis:aestheticRangeZeroOne"/>
                    <xs:attribute name="affect" type="vis:colorAffectType" default="fill">
                        <xs:annotation>
                            <xs:documentation>Type of color affected.  Fill colors are for the interior of a drawn object while a stroke color is for the edge of the drawn object.  Note that some objects, such as lines do not have an interior.  "main" is usually a fill color. "secondary" is usually a stroke color. "both" affects both. "fill" is explicitly a fill color.  "main" or "secondary" should be used in preference.  "stroke" is explicitly a stroke color.  "main" or "secondary" should be used in preference.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="position" type="vis:coordinate">
        <xs:annotation>
            <xs:documentation>Determines location along an axis</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="x" type="vis:coordinate">
        <xs:annotation>
            <xs:documentation>Determines location along the X (horizontal) axis</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="y" type="vis:coordinate">
        <xs:annotation>
            <xs:documentation>Determines location along the Y (vertical) axis</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="z" type="vis:coordinate">
        <xs:annotation>
            <xs:documentation>Determines location along the Z (front-back) axis. High Z is towards the front, low Z to the back</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:complexType name="aesthetic">
        <xs:annotation>
            <xs:documentation>An aesthetic maps data to a graphic attribute</xs:documentation>
        </xs:annotation>
        <xs:sequence minOccurs="0">
            <xs:element ref="vis:scale" minOccurs="0"/>
            <xs:group ref="vis:statistic" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="id" type="xs:ID"/>
        <xs:attributeGroup ref="vis:aestheticDataAttributes"/>
    </xs:complexType>
    <xs:attributeGroup name="aestheticDataAttributes">
        <xs:annotation>
            <xs:documentation>Data is taken from the variable</xs:documentation>
        </xs:annotation>
        <xs:attribute name="variable" type="xs:IDREF">
            <xs:annotation>
                <xs:documentation>The aesthetic will use data from this variable to map to the graphical characteristic</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="dimension" type="xs:nonNegativeInteger" default="0">
            <xs:annotation>
                <xs:documentation>If the variable is an expression that contains more than one dimension of data (for example the expression contained a cross of other variables), then this attribute specifies which of the variable's dimensions to use. The first in numbered 0, then 1, 2, etc.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="domain" type="xs:IDREF">
            <xs:annotation>
                <xs:documentation>If specified, this domain will be used to define the domain of the variable rather than the variable's default domain. For example, a user might choose to map 0 to black and 1 to white even if the data only run from 0.3 to 0.7. In this case a domain of [0,1] would be specified for the aesthetic.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="aestheticRangeLengths">
        <xs:annotation>
            <xs:documentation>Defines the output range of an aesthetic in terms of lengths</xs:documentation>
        </xs:annotation>
        <xs:attribute name="low" type="vis:length">
            <xs:annotation>
                <xs:documentation>The lowest value in the domain fo the aesthetic variable wil be mapped to this length</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="high" type="vis:length">
            <xs:annotation>
                <xs:documentation>The maximum value in an aesthetic variable's data will be mapped to this length</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:attributeGroup name="aestheticRangeZeroOne">
        <xs:annotation>
            <xs:documentation>Defines the output range of the aesthetic between 0 and 1</xs:documentation>
        </xs:annotation>
        <xs:attribute name="low" default="0">
            <xs:annotation>
                <xs:documentation>The lowest value in the domain of the aesthetic will be mapped to this number. Zero represents the lowest number the aesthetic could support and one represents the highest. For example, for brightness, 0 represents completely dark and 1 represents completely white.</xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:double">
                    <xs:minInclusive value="0"/>
                    <xs:maxInclusive value="1"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="high" default="1">
            <xs:annotation>
                <xs:documentation>The highest value in the domain of the aesthetic will be mapped to this number. Zero represents the lowest number the aesthetic could support and one represents the highest. For example, for brightness, 0 represents completely dark and 1 represents completely white.</xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:double">
                    <xs:minInclusive value="0"/>
                    <xs:maxInclusive value="1"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:attributeGroup>
    <xs:simpleType name="color">
        <xs:annotation>
            <xs:documentation>A concrete color definition, of the form #RRGGBB or one of the standard web color names</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="vis:colorName vis:colorRGBformat"/>
    </xs:simpleType>
    <xs:element name="split">
        <xs:annotation>
            <xs:documentation>A pseudo-aesthetic that does not actually change graphic appearance, but simply splits the element into subgroups based on a categorical variable</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:aesthetic"/>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="dimensionName">
        <xs:annotation>
            <xs:documentation>The name of a part of a coordinate system</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="x"/>
            <xs:enumeration value="y"/>
            <xs:enumeration value="z"/>
            <xs:enumeration value="theta"/>
            <xs:enumeration value="r"/>
            <xs:enumeration value="phi"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="length">
        <xs:annotation>
            <xs:documentation>An extent to be used to size or locate graphic entities</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="vis:lengthAbsolute vis:lengthPercentage"/>
    </xs:simpleType>
    <xs:simpleType name="locationMethodType">
        <xs:annotation>
            <xs:documentation>Defines how a location element will determine the size of its parent frame</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="fixed">
                <xs:annotation>
                    <xs:documentation>The location is determined by a fixed value; an absolute or percentage length</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="sizeToContent">
                <xs:annotation>
                    <xs:documentation>The location will choose a size to fit its contents. This can be used for 'width' and 'height' location parts</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="same">
                <xs:annotation>
                    <xs:documentation>Means that the value will be the same as a referenced frame</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="attach">
                <xs:annotation>
                    <xs:documentation>Means that the value will be the same as the opposite side of a referenced frame</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="locationPartType">
        <xs:annotation>
            <xs:documentation>Defines which aspect of a frame location is to be defined by a location</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="left"/>
            <xs:enumeration value="right"/>
            <xs:enumeration value="top"/>
            <xs:enumeration value="bottom"/>
            <xs:enumeration value="width"/>
            <xs:enumeration value="height"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="lengthPercentage">
        <xs:annotation>
            <xs:documentation>A length expressed as a percentage. The 100% size is determined by the context and typically is related to the size of the enclosing object</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:pattern value="-?[0-9]+[.]?[0-9]*%">
                <xs:annotation>
                    <xs:documentation>Any number followed by the percentage sign</xs:documentation>
                </xs:annotation>
            </xs:pattern>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="lengthAbsolute">
        <xs:annotation>
            <xs:documentation>A length expressed as an absolute value.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:pattern value="-?[0-9]+[.]?[0-9]*">
                <xs:annotation>
                    <xs:documentation>without any units defaults to pixels</xs:documentation>
                </xs:annotation>
            </xs:pattern>
            <xs:pattern value="-?[0-9]+[.]?[0-9]*mm">
                <xs:annotation>
                    <xs:documentation>length in millimeters</xs:documentation>
                </xs:annotation>
            </xs:pattern>
            <xs:pattern value="-?[0-9]+[.]?[0-9]*cm">
                <xs:annotation>
                    <xs:documentation>length in centimeters</xs:documentation>
                </xs:annotation>
            </xs:pattern>
            <xs:pattern value="-?[0-9]+[.]?[0-9]*in">
                <xs:annotation>
                    <xs:documentation>length in inches</xs:documentation>
                    <xs:documentation/>
                </xs:annotation>
            </xs:pattern>
            <xs:pattern value="-?[0-9]+[.]?[0-9]*px">
                <xs:annotation>
                    <xs:documentation>length in pixels</xs:documentation>
                </xs:annotation>
            </xs:pattern>
            <xs:pattern value="-?[0-9]+[.]?[0-9]*pt">
                <xs:annotation>
                    <xs:documentation>length in points</xs:documentation>
                </xs:annotation>
            </xs:pattern>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="colorRGBformat">
        <xs:annotation>
            <xs:documentation>A color expressed as #RRGGBB</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:pattern value="#[A-F,a-f,0-9]{6}"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="colorName">
        <xs:annotation>
            <xs:documentation>A named Color such as "red" or "lightGray"</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:pattern value="[A-Za-z]+"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="sourceVariable">
        <xs:annotation>
            <xs:documentation>Variables are used to construct visualizations and are defined in terms of source data. They are the link that defines how a column of data is to be used in the chart</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:variableType">
                    <xs:attribute name="sourceName" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>The name of this variable as it is know in the source</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="inputDateFormatPattern" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>The date input format pattern to be used in reading this variable.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="inputTimeZone" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>The date input time zone to use.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="categoricalDomain">
        <xs:annotation>
            <xs:documentation>A domain defines the range of values we expect data to lie in. This can be used to exclude values we do not want and to define standard ranges so data with different empirical ranges can be compared</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:domainType">
                    <xs:sequence>
                        <xs:choice minOccurs="0" maxOccurs="unbounded">
                            <xs:element ref="vis:variableReference"/>
                            <xs:element ref="vis:domainReference"/>
                            <xs:element name="categories">
                                <xs:annotation>
                                    <xs:documentation>Defines categories to be added to or removed from the domain</xs:documentation>
                                </xs:annotation>
                                <xs:complexType>
                                    <xs:simpleContent>
                                        <xs:extension base="xs:string">
                                            <xs:attribute name="remove" type="xs:boolean">
                                                <xs:annotation>
                                                    <xs:documentation>If true, these categories will be removed from the domain, otherwise they will be added to the domain</xs:documentation>
                                                </xs:annotation>
                                            </xs:attribute>
                                        </xs:extension>
                                    </xs:simpleContent>
                                </xs:complexType>
                            </xs:element>
                        </xs:choice>
                        <xs:choice minOccurs="0">
                            <xs:element name="statisticSort">
                                <xs:annotation>
                                    <xs:documentation>Sorts categories according to a statistic calculated on a continuous variable for rows with each category</xs:documentation>
                                </xs:annotation>
                                <xs:complexType>
                                    <xs:complexContent>
                                        <xs:extension base="vis:sortType">
                                            <xs:attribute name="sourceVariable" type="xs:IDREF" use="required">
                                                <xs:annotation>
                                                    <xs:documentation>This source variable contains categories that will be sorted. Typically this is a variable referenced in that section of this element. Categories not present will be sorted to one end of the list</xs:documentation>
                                                </xs:annotation>
                                            </xs:attribute>
                                            <xs:attribute name="statVariable" type="xs:IDREF">
                                                <xs:annotation>
                                                    <xs:documentation>The continuous variable that the statistic will use to determine a ranking of the categorical variable</xs:documentation>
                                                </xs:annotation>
                                            </xs:attribute>
                                            <xs:attribute name="method" type="vis:summaryType">
                                                <xs:annotation>
                                                    <xs:documentation>The summary method that should be used.</xs:documentation>
                                                </xs:annotation>
                                            </xs:attribute>
                                        </xs:extension>
                                    </xs:complexContent>
                                </xs:complexType>
                            </xs:element>
                            <xs:element name="simpleSort">
                                <xs:annotation>
                                    <xs:documentation>Sorts data either by occurance or alphanumerically</xs:documentation>
                                </xs:annotation>
                                <xs:complexType>
                                    <xs:complexContent>
                                        <xs:extension base="vis:sortType">
                                            <xs:sequence>
                                                <xs:element name="categoryOrder" type="xs:string" minOccurs="0">
                                                    <xs:annotation>
                                                        <xs:documentation>A semicolon separated list of the sorting order to use.</xs:documentation>
                                                    </xs:annotation>
                                                </xs:element>
                                            </xs:sequence>
                                            <xs:attribute name="method">
                                                <xs:annotation>
                                                    <xs:documentation>The sort method to be used</xs:documentation>
                                                </xs:annotation>
                                                <xs:simpleType>
                                                    <xs:restriction base="xs:string">
                                                        <xs:enumeration value="data">
                                                            <xs:annotation>
                                                                <xs:documentation>Sort in order that the data values are encountered.</xs:documentation>
                                                            </xs:annotation>
                                                        </xs:enumeration>
                                                        <xs:enumeration value="custom">
                                                            <xs:annotation>
                                                                <xs:documentation>Sort in order that the user specifies using the categoryOrder node.</xs:documentation>
                                                            </xs:annotation>
                                                        </xs:enumeration>
                                                        <xs:enumeration value="natural">
                                                            <xs:annotation>
                                                                <xs:documentation>Sort in natural order (e.g. alphabetical or numeric)</xs:documentation>
                                                            </xs:annotation>
                                                        </xs:enumeration>
                                                        <xs:enumeration value="naturalUsingLabel">
                                                            <xs:annotation>
                                                                <xs:documentation>Sort in natural order of labels.</xs:documentation>
                                                            </xs:annotation>
                                                        </xs:enumeration>
                                                    </xs:restriction>
                                                </xs:simpleType>
                                            </xs:attribute>
                                        </xs:extension>
                                    </xs:complexContent>
                                </xs:complexType>
                            </xs:element>
                        </xs:choice>
                    </xs:sequence>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="intervalDomain">
        <xs:annotation>
            <xs:documentation>A domain defines the range of values we expect data to lie in. This can be used to exclude values we do not want and to define standard ranges so data with different empirical rnges can be compared</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:domainType">
                    <xs:choice minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:documentation>Domains, variables and ranges to be included in this domain</xs:documentation>
                        </xs:annotation>
                        <xs:element ref="vis:variableReference"/>
                        <xs:element ref="vis:domainReference"/>
                        <xs:element name="range">
                            <xs:annotation>
                                <xs:documentation>An interval to be added to the domain or to reduce the domain to</xs:documentation>
                            </xs:annotation>
                            <xs:complexType>
                                <xs:attribute name="min" type="xs:string">
                                    <xs:annotation>
                                        <xs:documentation>The minimum value for this interval</xs:documentation>
                                    </xs:annotation>
                                </xs:attribute>
                                <xs:attribute name="max" type="xs:string">
                                    <xs:annotation>
                                        <xs:documentation>The maximum value for this interval</xs:documentation>
                                    </xs:annotation>
                                </xs:attribute>
                                <xs:attribute name="exact" type="xs:boolean">
                                    <xs:annotation>
                                        <xs:documentation>Whether to force exact interval values.</xs:documentation>
                                    </xs:annotation>
                                </xs:attribute>
                            </xs:complexType>
                        </xs:element>
                    </xs:choice>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="styleCycle">
        <xs:annotation>
            <xs:documentation>A way of generating styles to be used for a styleBy aesthetic</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:sequence>
                    <xs:element name="cycle" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:documentation>When getting the first style from a styleCycle, the first styles from each cycle are combined. The second style consists of the second style from the first cycle combined with the others and so on until that cycle is exhausted. Then the frist cycle resets to the first style and the second style from the second cycle is used. This means that, for example, a styleCycle with four cycles each containing three styles can generate 81 styles before wrapping </xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                            <xs:sequence>
                                <xs:element ref="vis:style" maxOccurs="unbounded"/>
                            </xs:sequence>
                            <xs:attribute name="id" type="xs:ID"/>
                        </xs:complexType>
                    </xs:element>
                </xs:sequence>
                <xs:element ref="vis:extension" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="id" type="xs:ID" />
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="dateOrNumber">
        <xs:annotation>
            <xs:documentation>A date or a number</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="vis:date xs:double"/>
    </xs:simpleType>
    <xs:simpleType name="date">
        <xs:annotation>
            <xs:documentation>One of the three legal ways to represent a date</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="xs:date xs:time xs:dateTime"/>
    </xs:simpleType>
    <xs:complexType name="coordinate">
        <xs:annotation>
            <xs:documentation>A coordinate used to locate a graphic representation of data within a coordinate system</xs:documentation>
        </xs:annotation>
        <xs:attribute name="id" type="xs:ID"/>
        <xs:attribute name="variable" type="xs:IDREF">
            <xs:annotation>
                <xs:documentation>This variable's data will be used to locate graphi items created by the element within the coordinate system</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="location" type="xs:string">
            <xs:annotation>
                <xs:documentation>If no variable is specified, this value (expressed in data units) will be used to locate all items created by this element. If there is no data on this dimension at all, the default range of [0,1] will be used and location values should be chosen to fit in that range</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:element name="dot">
        <xs:annotation>
            <xs:documentation>The Grammar of Graphics dot operator takes multiple variables to make a facet with all combinations of each of the variables</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice maxOccurs="unbounded">
                <xs:element ref="vis:variableReference"/>
                <xs:element ref="vis:unity"/>
                <xs:element ref="vis:blend"/>
                <xs:element ref="vis:cross"/>
                <xs:element ref="vis:bar"/>
                <xs:element ref="vis:dot"/>
                <xs:element ref="vis:nest"/>
            </xs:choice>
            <xs:attribute name="id" type="xs:ID"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="cross">
        <xs:annotation>
            <xs:documentation>The Grammar of Graphics cross operator takes multiple variables to make a facet with all combinations of each of the variables</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice maxOccurs="unbounded">
                <xs:element ref="vis:variableReference"/>
                <xs:element ref="vis:unity"/>
                <xs:element ref="vis:blend"/>
                <xs:element ref="vis:cross"/>
                <xs:element ref="vis:bar"/>
                <xs:element ref="vis:dot"/>
                <xs:element ref="vis:nest"/>
            </xs:choice>
            <xs:attribute name="id" type="xs:ID"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="blend">
        <xs:annotation>
            <xs:documentation>The Grammar of Graphics blend operator takes variables and merges them on the same dimension.  </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice maxOccurs="unbounded">
                <xs:element ref="vis:variableReference"/>
                <xs:element ref="vis:unity"/>
                <xs:element ref="vis:blend"/>
                <xs:element ref="vis:cross"/>
                <xs:element ref="vis:bar"/>
                <xs:element ref="vis:dot"/>
                <xs:element ref="vis:nest"/>
            </xs:choice>
            <xs:attribute name="id" type="xs:ID"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="unity">
        <xs:annotation>
            <xs:documentation>The Grammar of Graphics unity operand </xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="nest">
        <xs:annotation>
            <xs:documentation>The Grammar of Graphics nest operator takes two variables. The first is nested with in the second on the same dimension</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice maxOccurs="unbounded">
                <xs:element ref="vis:variableReference"/>
                <xs:element ref="vis:unity"/>
                <xs:element ref="vis:blend"/>
                <xs:element ref="vis:bar"/>
                <xs:element ref="vis:cross"/>
                <xs:element ref="vis:nest"/>
                <xs:element ref="vis:dot"/>
            </xs:choice>
            <xs:attribute name="id" type="xs:ID"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="bar">
        <xs:annotation>
            <xs:documentation>The Grammar of Graphics bar operator takes two variables. It is simialr to the nest operation except that (a*b)|(c*d) = a/c * b/d</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice maxOccurs="unbounded">
                <xs:element ref="vis:variableReference"/>
                <xs:element ref="vis:unity"/>
                <xs:element ref="vis:blend"/>
                <xs:element ref="vis:cross"/>
                <xs:element ref="vis:nest"/>
                <xs:element ref="vis:dot"/>
                <xs:element ref="vis:bar"/>
            </xs:choice>
            <xs:attribute name="id" type="xs:ID"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="extension">
        <xs:annotation>
            <xs:documentation>This element can be used as a simple way to store additional information in the ChartXML without requiring an additional schema</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:any processContents="skip"/>
            </xs:sequence>
            <xs:anyAttribute processContents="skip"/>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="improveLayout">
        <xs:annotation>
            <xs:documentation>This is a type that can be used to define an incremental improvement to a graph layout</xs:documentation>
        </xs:annotation>
        <xs:attribute name="ignoreLinkCrossings" type="xs:boolean">
            <xs:annotation>
                <xs:documentation>If true, link crossings are ignored, which is much faster for many edges</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="maxIterations">
            <xs:annotation>
                <xs:documentation>maximum number of iterations to run this agorithm for</xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:integer">
                    <xs:minInclusive value="1"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="maxTime">
            <xs:annotation>
                <xs:documentation>maximum amount of time to run algorithm for (approximately)</xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:double">
                    <xs:minExclusive value="0"/>
                    <xs:maxInclusive value="1000000"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="id" type="xs:ID"/>
    </xs:complexType>
    <xs:complexType name="frame">
        <xs:annotation>
            <xs:documentation>A rectangular area of the total display space</xs:documentation>
        </xs:annotation>
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:element ref="vis:extension" minOccurs="0"/>
            <xs:element ref="vis:location" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="id" type="xs:ID" >
            <xs:annotation>
                <xs:documentation>Identifier for this frame. Can be used as the value for a target so other frames can define their locations relative to this one</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="style" type="xs:IDREF">
            <xs:annotation>
                <xs:documentation>The frame is drawn with this style before any of its contents are drawn</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="clip" type="xs:boolean">
            <xs:annotation>
                <xs:documentation>If true, the frame will clip contents so they do not overflow its bounds. The default behavior may vary based on the contents of the frame</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="zOrder" type="xs:int">
            <xs:annotation>
                <xs:documentation>Integer which determines in what order things are drawn in.  If this is not specified things will draw in the order they are found in the specification.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:group name="aesthetic">
        <xs:annotation>
            <xs:documentation>A group with a choice of all the possible aeshetics</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element ref="vis:colorComponent"/>
            <xs:element ref="vis:color"/>
            <xs:element ref="vis:dash"/>
            <xs:element ref="vis:labeling"/>
            <xs:element ref="vis:offset"/>
            <xs:element ref="vis:pattern"/>
            <xs:element ref="vis:rotation"/>
            <xs:element ref="vis:shape"/>
            <xs:element ref="vis:size"/>
            <xs:element ref="vis:split"/>
            <xs:element ref="vis:styleBy"/>
            <xs:element ref="vis:transparency"/>
        </xs:choice>
    </xs:group>
    <xs:group name="statistic">
        <xs:annotation>
            <xs:documentation>A group with a choice of all the possible statistics</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element ref="vis:binStatistic"/>
            <xs:element ref="vis:edgeStatistic"/>
            <xs:element ref="vis:collectRowsStatistic"/>
            <xs:element ref="vis:distributionStatistic"/>
            <xs:element ref="vis:graphLayoutStatistic"/>
            <xs:element ref="vis:linkStatistic"/>
            <xs:element ref="vis:mapStatistic"/>
            <xs:element ref="vis:regionStatistic"/>
            <xs:element ref="vis:smoothStatistic"/>
            <xs:element ref="vis:summaryStatistic"/>
            <xs:element ref="vis:treeLayoutStatistic"/>
            <xs:element ref="vis:tukeyStatistic"/>
        </xs:choice>
    </xs:group>
    <xs:group name="format">
        <xs:annotation>
            <xs:documentation>A format for text, numbers, or dates for this domain</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element ref="vis:stringFormat"/>
            <xs:element ref="vis:numberFormat"/>
            <xs:element ref="vis:dateTimeFormat"/>
            <xs:element ref="vis:elapsedTimeFormat"/>
        </xs:choice>
    </xs:group>
    <xs:group name="guide">
        <xs:annotation>
            <xs:documentation>Group of all the available guides</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element ref="vis:frameGuide"/>
            <xs:element ref="vis:functionGuide"/>
            <xs:element ref="vis:lineGuide"/>
            <xs:element ref="vis:planeGuide"/>
            <xs:element ref="vis:pointGuide"/>
        </xs:choice>
    </xs:group>
    <xs:group name="element">
        <xs:annotation>
            <xs:documentation>Group of all the available guides</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element ref="vis:area"/>
            <xs:element ref="vis:interval"/>
            <xs:element ref="vis:line"/>
            <xs:element ref="vis:link"/>
            <xs:element ref="vis:path"/>
            <xs:element ref="vis:point"/>
            <xs:element ref="vis:polygon"/>
            <xs:element ref="vis:schema"/>
        </xs:choice>
    </xs:group>
    <xs:group name="variable">
        <xs:annotation>
            <xs:documentation>Group of all the different variables</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element ref="vis:derivedVariable"/>
            <xs:element ref="vis:expressionVariable"/>
            <xs:element ref="vis:sourceVariable"/>
        </xs:choice>
    </xs:group>
    <xs:group name="interaction">
        <xs:annotation>
            <xs:documentation>Group of all the elements for interaction</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element ref="vis:popup"/>
            <xs:element ref="vis:drillDown"/>
            <xs:element ref="vis:brushing"/>
            <xs:element ref="vis:time"/>
            <xs:element name="dragElement">
                <xs:annotation>
                    <xs:documentation>Defines an interaction that allows elements to be dragged from their normal places</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:attribute name="target" type="xs:IDREF" use="required">
                        <xs:annotation>
                            <xs:documentation>The element to allow drag on</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="id" type="xs:ID">
                        <xs:annotation>
                            <xs:documentation>ID for the spec</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:complexType>
            </xs:element>
        </xs:choice>
    </xs:group>
    <xs:simpleType name="mappingMethod">
        <xs:annotation>
            <xs:documentation>Method to use to modify a domain to extend it to the next nearest nice number</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="nice">
                <xs:annotation>
                    <xs:documentation>extend to the next nearest 'nice' number</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="exact">
                <xs:annotation>
                    <xs:documentation>Leave it exactly as defined by the domain</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="breakRepresentationType">
        <xs:annotation>
            <xs:documentation>How to represent a break in a boundary elemen (path, line, area)</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="gap">
                <xs:annotation>
                    <xs:documentation>extend to the next nearest 'nice' number</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="interpolate">
                <xs:annotation>
                    <xs:documentation>Leave it exactly as defined by the domain</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="wings"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="labelType">
        <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element name="descriptionGroup">
                <xs:annotation>
                    <xs:documentation>A target XML element is used to generate text to be inserted in the label. A mix of text and description elements is allowed and typically used</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:choice minOccurs="0" maxOccurs="unbounded">
                        <xs:element name="description">
                            <xs:annotation>
                                <xs:documentation>A short piece of text acquired from an item that describes one feature of that item</xs:documentation>
                            </xs:annotation>
                            <xs:complexType>
                                <xs:sequence minOccurs="0">
                                    <xs:group ref="vis:format"/>
                                </xs:sequence>
                                <xs:attribute name="name" type="xs:string" use="required">
                                    <xs:annotation>
                                        <xs:documentation>The name of the description requested from the target XML element. This might be as simple as "name" or more complex such as "r-squared". Different XML elements provide different possible descriptions</xs:documentation>
                                    </xs:annotation>
                                </xs:attribute>
                                <xs:attribute name="id" type="xs:ID"/>
                            </xs:complexType>
                        </xs:element>
                        <xs:element name="text" type="vis:textType">
                            <xs:annotation>
                                <xs:documentation>A fixed string of text</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:choice>
                    <xs:attribute name="target" type="xs:IDREF" use="required">
                        <xs:annotation>
                            <xs:documentation>The ID of the item for which a description is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="separator" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>If the targeted item has multiple groups, their descriptions are separated by this string.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="id" type="xs:string"/>
                </xs:complexType>
            </xs:element>
            <xs:element name="text" type="vis:textType">
                <xs:annotation>
                    <xs:documentation>A fixed string of text</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element ref="vis:alternateLabel"/>
        </xs:choice>
        <xs:attribute name="id" type="xs:ID"/>
        <xs:attribute name="style" type="xs:IDREF">
            <xs:annotation>
                <xs:documentation>The style for the text of the label.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="textFrameStyle" type="xs:IDREF">
            <xs:annotation>
                <xs:documentation>The style for the plaque around the text.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="link" type="xs:string">
            <xs:annotation>
                <xs:documentation>If supplied, this indicates that clicking on this label should follow the indicated link</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="zOrder" type="xs:int">
            <xs:annotation>
                <xs:documentation>Integer which determines in what order things are drawn in.  If this is not specified things will draw in the order they are found in the specification.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="elementType">
        <xs:sequence>
            <xs:element ref="vis:extension" minOccurs="0"/>
            <xs:element ref="vis:conditionalStyle" minOccurs="0" maxOccurs="unbounded"/>
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>A sequence of statistics defines as chain; each statistic is applied to the results of the previous statistic. A common use is binnign followed by a summary</xs:documentation>
                </xs:annotation>
                <xs:group ref="vis:statistic"/>
            </xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>A sequence of aesthetics is applied in order; later aesthetics might override the values set by previous aesthetics</xs:documentation>
                </xs:annotation>
                <xs:group ref="vis:aesthetic"/>
            </xs:choice>
            <xs:choice>
                <xs:sequence>
                    <xs:element ref="vis:position" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element ref="vis:x" minOccurs="0"/>
                    <xs:element ref="vis:y" minOccurs="0"/>
                    <xs:element ref="vis:z" minOccurs="0"/>
                </xs:sequence>
                <xs:element ref="vis:attach"/>
            </xs:choice>
        </xs:sequence>
        <xs:attribute name="id" type="xs:ID" >
            <xs:annotation>
                <xs:documentation>Identifier for this element</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="clip">
            <xs:annotation>
                <xs:documentation>What kind of clipping should be done on the element.</xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="none"/>
                    <xs:enumeration value="cell"/>
                    <xs:enumeration value="domain"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="style" type="xs:IDREF">
            <xs:annotation>
                <xs:documentation>The basic style of this element.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="name" type="xs:string">
            <xs:annotation>
                <xs:documentation>A human-readable string that may be used to name the element in a legend or to be read by a screen reader. If not defined, the ID will be used instead.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="dot" type="xs:boolean">
            <xs:annotation>
                <xs:documentation>usually an element's expression is to be crossed with the faceting, so that blends in the facetiing will induce multiple copies iof the data in the grap. If this parameter is set to ture, the expressions will be dotted together, making fewer copies.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="labelCollisionHandling">
            <xs:annotation>
                <xs:documentation>Allows the use of one or more algorithms to avoid labels colliding, by moving them slightly around their original positions</xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="none">
                        <xs:annotation>
                            <xs:documentation>labels will not be moved</xs:documentation>
                        </xs:annotation>
                    </xs:enumeration>
                    <xs:enumeration value="normal">
                        <xs:annotation>
                            <xs:documentation>Labels will be moved so as to avoid collisions. A short amount of time will be allocated to this algorithm</xs:documentation>
                        </xs:annotation>
                    </xs:enumeration>
                    <xs:enumeration value="fast">
                        <xs:annotation>
                            <xs:documentation>Labels will be moved so as to avoid collisions. A very short amount of time will be allocated to this algorithm; effectively it will not attempt many changes</xs:documentation>
                        </xs:annotation>
                    </xs:enumeration>
                    <xs:enumeration value="quality">
                        <xs:annotation>
                            <xs:documentation>Labels will be moved so as to avoid collisions. A long amount of time will be allocated to this algorithm; possibly up to a half second or so</xs:documentation>
                        </xs:annotation>
                    </xs:enumeration>
                    <xs:enumeration value="extreme">
                        <xs:annotation>
                            <xs:documentation>Labels will be moved so as to avoid collisions. The process will be allowed to run for a very long period of time; many seconds or so are possible. This option should only be used when time is not important</xs:documentation>
                        </xs:annotation>
                    </xs:enumeration>
                    <xs:enumeration value="basic">
                        <xs:annotation>
                            <xs:documentation>Labels will be moved so as to avoid collisions. The process will be allowed to run for a very long period of time; many seconds or so are possible. This option should only be used when time is not important</xs:documentation>
                        </xs:annotation>
                    </xs:enumeration>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="showCollidingLabels" type="xs:boolean">
            <xs:annotation>
                <xs:documentation>If no label collsion handling is attempted, or if afterwards labels still collide, this parameter is consulted to see whether a label will be drawn even if it collides with a previously drawn label</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="coordinates" type="xs:IDREF">
            <xs:annotation>
                <xs:documentation>Defines the coordinate system an element will be drawn within. If left undefined, the first coordinate system defined by the graph will be used. This attribute is intended to be used only for graphs with multiple coordinate systems, such as SPLOMS with histograms on the diagonal</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="positionModifier">
            <xs:annotation>
                <xs:documentation>For elements that would be mapped to the same position, this attribute allows them to be stacked on top of each other, dodged to either side of each other or have the intersection of their ranges removed form each of them (a difference effect)</xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="center"/>
                    <xs:enumeration value="stack"/>
                    <xs:enumeration value="stackInterpolating"/>
                    <xs:enumeration value="stackReverse"/>
                    <xs:enumeration value="stackInterpolatingReverse"/>
                    <xs:enumeration value="setMissingsToZero"/>
                    <xs:enumeration value="minusIntersection"/>
                    <xs:enumeration value="dodge"/>
                    <xs:enumeration value="pile"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="xLocation" type="xs:double"/>
        <xs:attribute name="yLocation" type="xs:double"/>
        <xs:attribute name="zLocation" type="xs:double"/>
        <xs:attribute name="zOrder" type="xs:int">
            <xs:annotation>
                <xs:documentation>Integer which determines in what order things are drawn in.  If this is not specified things will draw in the order they are found in the specification.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <!--		<xs:attribute name="clip" type="xs:boolean">-->
        <!--			<xs:annotation>-->
        <!--				<xs:documentation>If true, the iinermost frame will clip elements so they do not overflow its bounds. The default behavior may vary</xs:documentation>-->
        <!--			</xs:annotation>-->
        <!--		</xs:attribute>-->
    </xs:complexType>
    <xs:complexType name="variableType">
        <xs:sequence>
            <xs:element ref="vis:extension" minOccurs="0"/>
            <xs:element name="aggregation" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Aggregates categories of a categorical variable based on the sum of values of a different variable</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:attribute name="newCategory" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:documentation>The name of the category which will be created if any aggregation occurs</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="sumVariable" type="xs:IDREF" use="required">
                        <xs:annotation>
                            <xs:documentation>The variable to add up for each category to determine the category's size</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="minFraction" use="required">
                        <xs:annotation>
                            <xs:documentation>The fraction (between 0 and 1) that will be used to determine if a category is to be aggregated. If a category has a summed value less than the given fraction of the overall sum, it will be aggregated unless it is the only such category (in which case there is nothing to aggregate it with!)</xs:documentation>
                        </xs:annotation>
                        <xs:simpleType>
                            <xs:restriction base="xs:double">
                                <xs:minInclusive value="0"/>
                                <xs:maxInclusive value="1"/>
                            </xs:restriction>
                        </xs:simpleType>
                    </xs:attribute>
                    <xs:attribute name="id" type="xs:ID"/>
                </xs:complexType>
            </xs:element>
            <xs:group ref="vis:format" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="id" type="xs:ID" >
            <xs:annotation>
                <xs:documentation>Identiifes the variable</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="categorical" type="xs:boolean">
            <xs:annotation>
                <xs:documentation>Whether this data is categorical or not. If not, and it is not a date, the data values will be converted to doubles. The difference between a categorical and non-categorical variable is profound and determines whether it can be used for faceting, which aesthetics it can be used for, and other purposes. It is legal and often useful to have two variables use the same base data with different values for categorical and/or other attributes</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="label" type="xs:string">
            <xs:annotation>
                <xs:documentation>A human-readable name for the variable (defaults to the ID)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="shortLabel" type="xs:string">
            <xs:annotation>
                <xs:documentation>A short human-readable label for the variable (defaults to the label)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="domain" type="xs:IDREF">
            <xs:annotation>
                <xs:documentation>All data exist in some domain, and that domain is used to control what the "minimum" and "maximum" values are. By default, the domain of a variable is defined to be the data range (for continuous variables) or the set of unique values of a variable (for categorical variables). If this parameter is specified, the default domain is replaced with this one</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="labelVariable" type="xs:IDREF">
            <xs:annotation>
                <xs:documentation>By default, the values of a categorical variable are used as the labels. If this attribute is specified, the given variable is used to label the categories of this variable. The label variable must be of the same length as this variable, since it matches on a row by row basis, and both must be categorical variables.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="weight" type="xs:boolean">
            <xs:annotation>
                <xs:documentation>If true, this variable will be used as a sample weight for all data in the same source. At most one weight may be defined for a source.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="key" type="xs:boolean">
            <xs:annotation>
                <xs:documentation>Indicates the variable can be used as a database key; all entries in it should be unique</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="creator" type="xs:string">
            <xs:annotation>
                <xs:documentation>The creator of this variable</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="description" type="xs:string">
            <xs:annotation>
                <xs:documentation>A descritption of the variable for human or machine use</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="source" type="xs:IDREF">
            <xs:annotation>
                <xs:documentation>The data source this variable is from.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:element name="expressionVariable">
        <xs:annotation>
            <xs:documentation>Expression variables use agrammar of graphics expression to calculate a complex variable. This 'variable' may be multi-dimensional and its use in that case is determined by context. Used as a positional variable (for example, the 'x' value of an element) it may induce faceting. In an aesthetic, only one dimension is likely to be used.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:variableType">
                    <xs:attribute name="expression" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>The expression in this attribute should be a legal Grammar of Graphics expression (with the additional dot operator) based on existing variables and the unity variable '1'</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="derivedVariable">
        <xs:annotation>
            <xs:documentation>Derived variables are variables that are derived from other source variables by means of a mathematical expression.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:variableType">
                    <xs:attribute name="value" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>This variable is derived by calculating the expression given by this atribute. Examples would be 'log(1+x)' or '(a-b)/(a+b)' , where x, a and b are the ids of other source variables</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="domainType">
        <xs:sequence>
            <xs:group ref="vis:format" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="id" type="xs:ID" >
            <xs:annotation>
                <xs:documentation>Identifier for the domain</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="date">
            <xs:annotation>
                <xs:documentation>If true, then the domain is for dates</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="formatType">
        <xs:annotation>
            <xs:documentation>To be used for formattiing</xs:documentation>
        </xs:annotation>
        <xs:attribute name="id" type="xs:ID"/>
        <xs:attribute name="prefix" type="xs:string">
            <xs:annotation>
                <xs:documentation>prepend the value with this string</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="suffix" type="xs:string">
            <xs:annotation>
                <xs:documentation>append the value with this string</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="textType">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="id" type="xs:ID"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    <xs:complexType name="ticksType">
        <xs:sequence>
            <xs:element ref="vis:gridline" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="id" type="xs:ID" >
            <xs:annotation>
                <xs:documentation>Identifier for the item</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="position">
            <xs:annotation>
                <xs:documentation>The allowed positions for tick marks relative to the axis baseline</xs:documentation>
            </xs:annotation>
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="inside">
                        <xs:annotation>
                            <xs:documentation>The ticks will be inside the axis</xs:documentation>
                        </xs:annotation>
                    </xs:enumeration>
                    <xs:enumeration value="outside">
                        <xs:annotation>
                            <xs:documentation>The ticks will be outside the axis</xs:documentation>
                        </xs:annotation>
                    </xs:enumeration>
                    <xs:enumeration value="cross">
                        <xs:annotation>
                            <xs:documentation>The ticks will cross the axis</xs:documentation>
                        </xs:annotation>
                    </xs:enumeration>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="markStyle" type="xs:IDREF">
            <xs:annotation>
                <xs:documentation>style for the actual tick marks - the small line not including the label</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="length" type="vis:length">
            <xs:annotation>
                <xs:documentation>The tickmark length. If undefined a value is chosen proportional to the font size used for the tick labels</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="zOrder" type="xs:int">
            <xs:annotation>
                <xs:documentation>Integer which determines in what order things are drawn in.  If this is not specified things will draw in the order they are found in the specification.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:element name="summaryStatistic">
        <xs:annotation>
            <xs:documentation>Summarizes the dependant variable for a set of data conditional on the values of the other position variables.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID"/>
            <xs:attribute name="convertIntervalToSingleValue" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation>If true, a summary statistic that is an interval (such as a confidence interval) will be converted to a sinlge value, the difference between the upper and lower values.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="method" type="vis:summaryType">
                <xs:annotation>
                    <xs:documentation>The method used to summarize the data.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="summaryBase" type="vis:summaryBaseType">
                <xs:annotation>
                    <xs:documentation>The base for a percentage or fraction summary.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="percent">
                <xs:annotation>
                    <xs:documentation>The percentage value to be used in the confidence interval summary.</xs:documentation>
                </xs:annotation>
                <xs:simpleType>
                    <xs:restriction base="xs:double">
                        <xs:minInclusive value="0"/>
                        <xs:maxExclusive value="100"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="summaryIndex">
                <xs:annotation>
                    <xs:documentation>The index of the aesthetic or coordiante to use to set for 100%</xs:documentation>
                </xs:annotation>
                <xs:simpleType>
                    <xs:restriction base="xs:integer">
                        <xs:minInclusive value="1"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="summaryAcrossPanels" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation>If true, the sumamry abse will be across panels</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="treeLayoutStatistic">
        <xs:annotation>
            <xs:documentation>Lays out a tree as a set of polygons using a space filling technique.  This is in contrast to graphLayoutStatistic which lays out a tree as a set of nodes and edges.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID"/>
            <xs:attribute name="addChildSizes" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation>If true, then the size variable specifies the size of the node not including its children (therefore the children sizes need to be added to get the total size). If false, then the size variable already includes the size of the children. In that case, it is an error if the children sizes add up to more then the node size. If there is no size variable, this flag is ignored.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="itemVariable" type="xs:IDREF">
                <xs:annotation>
                    <xs:documentation>The variable to use for the unique identifiers for the nodes in the tree.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="method" type="vis:treeLayoutMethodType">
                <xs:annotation>
                    <xs:documentation>The method to be used to lay out the tree.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="padding" type="vis:length">
                <xs:annotation>
                    <xs:documentation>The amount of space to use between nodes and their parents in the tree.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="parent" type="xs:IDREF">
                <xs:annotation>
                    <xs:documentation>The variable to be used to identify the parents of nodes in the tree.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="sizeVariable" type="xs:IDREF">
                <xs:annotation>
                    <xs:documentation>The variable that gives the size of each tree node.  If not specified all nodes are assumed to be the same size.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="spacing" type="vis:length">
                <xs:annotation>
                    <xs:documentation>The amount of spacing to place between sibling nodes in the tree.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="tukeyStatistic">
        <xs:annotation>
            <xs:documentation>Calculates Tukey Letter Values.  The main use of this is for boxplots.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="smoothStatistic">
        <xs:annotation>
            <xs:documentation>Fits a model to the data in order to provide a smooth version of the data.  Common examples include simple linear regression, polynomial regression, loess curve fitting, and kernel smoothing.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID"/>
            <xs:attribute name="bandwith">
                <xs:annotation>
                    <xs:documentation>The width used for kernel smooths</xs:documentation>
                </xs:annotation>
                <xs:simpleType>
                    <xs:restriction base="xs:double">
                        <xs:minExclusive value="0"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="bounded" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation>Sets whether or not the model is bounded.  If true, then the model is bounded.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="cutpoints" type="xs:string">
                <xs:annotation>
                    <xs:documentation>The cutpoints used in the model. This should be an array of doubles seperated by semicolons.  For example 4.5;.2;4;1.7E25</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="degree" type="xs:integer">
                <xs:annotation>
                    <xs:documentation>The degree of the polynomial model.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="firstStep" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation>Whether or not the first step is set.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="gridded" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation>Whether or not to predict on gridded data.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="kernel" type="vis:kernelType">
                <xs:annotation>
                    <xs:documentation>The type of kernel to use for kernel smoothing.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="marron" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation>Whether or not to use the Marron adjustment for discrete data.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="method" type="vis:smoothMethodType">
                <xs:annotation>
                    <xs:documentation>The model to use to smooth data.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="neighbors" type="xs:integer">
                <xs:annotation>
                    <xs:documentation>The number of neighbors to use for nearest neighbor kernel model.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="proportion">
                <xs:annotation>
                    <xs:documentation>The proportion of the data to use for kernel models not based on nearest neighbors.</xs:documentation>
                </xs:annotation>
                <xs:simpleType>
                    <xs:restriction base="xs:double">
                        <xs:minInclusive value="0"/>
                        <xs:maxInclusive value="1"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="robust" type="vis:robustType">
                <xs:annotation>
                    <xs:documentation>The method for calculating robust statistics.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="segments" type="xs:integer">
                <xs:annotation>
                    <xs:documentation>The number of segments to predict.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="spikes" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation>Whether or not to generate spikes to the fit line instead of actually generating the fit line.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="window" type="vis:windowType">
                <xs:annotation>
                    <xs:documentation>The type of window to use for a kernel smooth model.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="regionStatistic">
        <xs:annotation>
            <xs:documentation>Calculates regions of confidence such as confidence intervals.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID"/>
            <xs:attribute name="alpha">
                <xs:annotation>
                    <xs:documentation>The alpha value.  Only used in som models.</xs:documentation>
                </xs:annotation>
                <xs:simpleType>
                    <xs:restriction base="xs:double">
                        <xs:minInclusive value="0"/>
                        <xs:maxInclusive value="1"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="bounded" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation>If true then the model is bounded.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="numberConditionals" type="xs:integer">
                <xs:annotation>
                    <xs:documentation>Number of conditionals on a model.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="cutPoints" type="xs:string">
                <xs:annotation>
                    <xs:documentation>An array of double seperated by semicolons.  For example 4.5;.2;4;1.7E25</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="degree" type="xs:integer">
                <xs:annotation>
                    <xs:documentation>Degree of a polynomial model.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="df1" type="xs:double">
                <xs:annotation>
                    <xs:documentation>The first degree of freedom of a model.  If a model has only one degree of freedom, this is it.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="df2" type="xs:double">
                <xs:annotation>
                    <xs:documentation>The second degree of freedom of a model.  If a model has only one degree of freedom, this will be ignored.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="distribution" type="vis:distributionType">
                <xs:annotation>
                    <xs:documentation>Distribution (or model) for which the region will be calculated.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="location" type="vis:regionLocationType">
                <xs:annotation>
                    <xs:documentation>The measure of central tendancy for which the region will be calculated.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="predictIndividuals" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation>If true, individuals will be predicted. If false, the mean value will be predicted.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="segments" type="xs:integer">
                <xs:annotation>
                    <xs:documentation>number of segments to predict. </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="regionType" type="vis:regionModelType">
                <xs:annotation>
                    <xs:documentation>the type of region to calculate the statistic for.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="mapStatistic">
        <xs:annotation>
            <xs:documentation>Defines a set of map features based on a map source and a variable defining keys into that map source.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID"/>
            <xs:attribute name="mapFile" type="xs:string">
                <xs:annotation>
                    <xs:documentation>File path or URL to map file.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="showAll" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation>If true, all map features will be shown.  If fale, only those matching data will be shown.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="mapKey" type="xs:string">
                <xs:annotation>
                    <xs:documentation>Name of the key in the map used to match map features in the map file.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="layer" type="xs:string" use="required">
                <xs:annotation>
                    <xs:documentation>Layer within the map file currently being used.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="keyVariable" type="xs:IDREF">
                <xs:annotation>
                    <xs:documentation>Variable in the data used as a key to match map features in the map file. The values from the variable specified must match the key values found in the map file.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="sourceFormat">
                <xs:annotation>
                    <xs:documentation>Format of the source map file.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="dataKey">
                <xs:annotation>
                    <xs:documentation>The variable in the data used as a key to match map features in the map file. The values from the variable specified must match the key values found in the map file.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="linkStatistic">
        <xs:annotation>
            <xs:documentation>linkStatistic creates links from data points to a common location.  Each dimension can have a different common location method.  Any dimension left unspecified will copy the locations from the data points.
For example: a linkStatistic that links sets the X-dimension link type to "origin" will create links from data points to new data locations that have the same Y coordinates as the original data, but all have the same X coordinates (the origin).

In contrast, a linkStatistic that sets both the X and Y-dimension link types to "origin" will create links from data points to a single new location.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID"/>
            <xs:attribute name="x" type="vis:linkToType">
                <xs:annotation>
                    <xs:documentation>what location to link the X dimension to.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="y" type="vis:linkToType">
                <xs:annotation>
                    <xs:documentation>what location to link the Y dimension to.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="z" type="vis:linkToType">
                <xs:annotation>
                    <xs:documentation>what location to link the Z dimension to.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="graphLayoutStatistic">
        <xs:annotation>
            <xs:documentation>lays out the edges of a node/edge graph.  Note that the edge variables are required while the weight variable is optional.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="initial" minOccurs="0">
                    <xs:complexType>
                        <xs:attribute name="type" type="vis:graphLayoutType">
                            <xs:annotation>
                                <xs:documentation>method used to layout the graph initially</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="id" type="xs:ID"/>
                    </xs:complexType>
                </xs:element>
                <xs:choice minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="swap" type="vis:improveLayout">
                    </xs:element>
                    <xs:element name="randomize">
                        <xs:complexType>
                            <xs:complexContent>
                                <xs:extension base="vis:improveLayout">
                                    <xs:attribute name="failuresNeededToStop" type="xs:integer">
                                        <xs:annotation>
                                            <xs:documentation>The number of successive failures needed to terminate this algorithm</xs:documentation>
                                        </xs:annotation>
                                    </xs:attribute>
                                </xs:extension>
                            </xs:complexContent>
                        </xs:complexType>
                    </xs:element>
                    <xs:element name="move">
                        <xs:complexType>
                            <xs:complexContent>
                                <xs:extension base="vis:improveLayout">
                                    <xs:attribute name="initialDistance">
                                        <xs:annotation>
                                            <xs:documentation>The initial distance to try moving nodes. In (0,1)</xs:documentation>
                                        </xs:annotation>
                                        <xs:simpleType>
                                            <xs:restriction base="xs:double">
                                                <xs:minExclusive value="0"/>
                                                <xs:maxExclusive value="1"/>
                                            </xs:restriction>
                                        </xs:simpleType>
                                    </xs:attribute>
                                    <xs:attribute name="reductionFactor">
                                        <xs:annotation>
                                            <xs:documentation>Each step, the amount to move nodes by is multiplied by this factor, which must be in the range (0,1]</xs:documentation>
                                        </xs:annotation>
                                        <xs:simpleType>
                                            <xs:restriction base="xs:double">
                                                <xs:minExclusive value="0"/>
                                                <xs:maxExclusive value="1"/>
                                            </xs:restriction>
                                        </xs:simpleType>
                                    </xs:attribute>
                                </xs:extension>
                            </xs:complexContent>
                        </xs:complexType>
                    </xs:element>
                </xs:choice>
                <xs:element name="fixedNode" minOccurs="0" maxOccurs="unbounded">
                    <xs:complexType>
                        <xs:attribute name="id" type="xs:ID"/>
                        <xs:attribute name="node" type="xs:string">
                            <xs:annotation>
                                <xs:documentation>The name (id) of the node to place at a fixed location</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="x" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>the x location to move to</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="y" type="xs:double">
                            <xs:annotation>
                                <xs:documentation>the y location to move to</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>
            <xs:attribute name="id" type="xs:ID"/>
            <xs:attribute name="from" type="xs:IDREF">
                <xs:annotation>
                    <xs:documentation>variable that defines the start of edges.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="to" type="xs:IDREF">
                <xs:annotation>
                    <xs:documentation>variable that defines the end of edges.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="weight" type="xs:IDREF">
                <xs:annotation>
                    <xs:documentation>variable that defines weights for edges.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="time" type="xs:double">
                <xs:annotation>
                    <xs:documentation>max amount of time in seconds to lay out graph</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="distributionStatistic">
        <xs:annotation>
            <xs:documentation>merges all the rows of a table so that aesthetics calculated on them are all the same.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="collectRowsStatistic">
        <xs:annotation>
            <xs:documentation>merges all the rows of a table so that aesthetics calculated on them are all the same.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="edgeStatistic">
        <xs:annotation>
            <xs:documentation>Generates edges between the points</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID"/>
            <xs:attribute name="type" type="vis:edgeType">
                <xs:annotation>
                    <xs:documentation>The method used to generate edges</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="binStatistic">
        <xs:annotation>
            <xs:documentation>A bin statistic bins the data into regular bins. If unspecifed, bin sizes is calculated automatically.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID"/>
            <xs:attribute name="binCount" type="xs:string">
                <xs:annotation>
                    <xs:documentation>An array of counts for the number of bins, one for each dimension on which binning will occur. This may not be specified in conjunction with binWidth</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="binWidth" type="xs:string">
                <xs:annotation>
                    <xs:documentation>An array of sizes (in data units) for bins, one for each dimension on which binning will occur. This may not be specified in conjunction with binCount</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="binStart" type="xs:string">
                <xs:annotation>
                    <xs:documentation>An array of start locations for the bins, one for each dimension on which binning will occur. </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="gridType" type="vis:gridType"/>
            <xs:attribute name="location" type="vis:binLocationType"/>
            <xs:attribute name="method" type="vis:binMethodType"/>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="gridType">
        <xs:annotation>
            <xs:documentation>Defines the shape of bins to use.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="hex"/>
            <xs:enumeration value="dot"/>
            <xs:enumeration value="square"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="binLocationType">
        <xs:annotation>
            <xs:documentation>Represents when you bin data, where the resulting value is placed relative to the bin.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="grid"/>
            <xs:enumeration value="centroid"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="binMethodType">
        <xs:annotation>
            <xs:documentation>Which dimensions to bin, an whether to aggregate</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="aggregate"/>
            <xs:enumeration value="allDimensions"/>
            <xs:enumeration value="notResponse"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="graphLayoutType">
        <xs:annotation>
            <xs:documentation>Defines the possible types of graph layouts.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="grid"/>
            <xs:enumeration value="random"/>
            <xs:enumeration value="tree"/>
            <xs:enumeration value="polarTree"/>
            <xs:enumeration value="circle"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="linkToType">
        <xs:annotation>
            <xs:documentation>Defines the possible types of graph layouts.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="centroid">
                <xs:annotation>
                    <xs:documentation>specifies that a link should terminate at the mean value of the group the statistic is being calculated on.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="base">
                <xs:annotation>
                    <xs:documentation>specifies that a link should terminate at the "bottom" of the plot area.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="origin">
                <xs:annotation>
                    <xs:documentation>specifies that a link should terminate at the origin of the charts coordinate space.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="midrange">
                <xs:annotation>
                    <xs:documentation>specifies that a link should terminate at the middle of the range of values of the group the statistic is being calculated on.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="mapSourceFormatType">
        <xs:annotation>
            <xs:documentation>Specifies the format of a map source.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="text">
                <xs:annotation>
                    <xs:documentation>A proprietary text format intended for simple map descriptions.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="basic">
                <xs:annotation>
                    <xs:documentation>A proprietary binary format intended for single layer optimized map files.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="multiLayer">
                <xs:annotation>
                    <xs:documentation>A proprietary binary format intended for complex, multi-layer map files.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="distributionType">
        <xs:annotation>
            <xs:documentation>States the type of statistical distribution (also known as model) used in the calculation of a statistic.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="uniform">
                <xs:annotation>
                    <xs:documentation>indicates that the uniform distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="normal">
                <xs:annotation>
                    <xs:documentation>indicates that the normal distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="t">
                <xs:annotation>
                    <xs:documentation>indicates that the t distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="f">
                <xs:annotation>
                    <xs:documentation>indicates that the f distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="chisquare">
                <xs:annotation>
                    <xs:documentation>indicates that the chisquare distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="gamma">
                <xs:annotation>
                    <xs:documentation>indicates that the gamma distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="beta">
                <xs:annotation>
                    <xs:documentation>indicates that the beta distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="exponential">
                <xs:annotation>
                    <xs:documentation>indicates that the exponential distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="logistic">
                <xs:annotation>
                    <xs:documentation>indicates that the logistic distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="studentizedrange">
                <xs:annotation>
                    <xs:documentation>indicates that the studentized range distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="weibull">
                <xs:annotation>
                    <xs:documentation>indicates that the weibull distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="binomial">
                <xs:annotation>
                    <xs:documentation>indicates that the binomial distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="poisson">
                <xs:annotation>
                    <xs:documentation>indicates that the poisson distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="colorAffectType">
        <xs:annotation>
            <xs:documentation> Type of color affected.  Fill colors are for the interior of a drawn object while a stroke color is for the edge of the drawn object.  Note that some objects, such as lines do not have an interior.
MAIN is usually a fill color.
SECONDARY is usually a stroke color.
BOTH affects both.
FILL is explicitly a fill color.  MAIN or SECONDARY should be used in preference.
STROKE is explicitly a stroke color.  MAIN or SECONDARY should be used in preference.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="both">
                <xs:annotation>
                    <xs:documentation>Both the main color and the secondary color will be affected.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="main">
                <xs:annotation>
                    <xs:documentation> The main color which is usually a fill color will be affected.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="secondary">
                <xs:annotation>
                    <xs:documentation>The secondary color which is usually a draw color will be affected.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="stroke">
                <xs:annotation>
                    <xs:documentation>Always affect the stroke.  For most purposes, it is better to use MAIN or SECONDARY.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="fill">
                <xs:annotation>
                    <xs:documentation>Always affect the fill.  For most purposes, it is better to use MAIN or SECONDARY.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="regionLocationType">
        <xs:annotation>
            <xs:documentation> defines the central measure to be used to define confidence and other intervals.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="mean">
                <xs:annotation>
                    <xs:documentation>Used when the mean is desired.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="median">
                <xs:annotation>
                    <xs:documentation>Used when the median is desired.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="mode">
                <xs:annotation>
                    <xs:documentation>Used when the mode is desired.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="regionModelType">
        <xs:annotation>
            <xs:documentation>Used to defines the distribution or model to be used in the calculation of a region statistic.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="uniform">
                <xs:annotation>
                    <xs:documentation>indicates that the uniform distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="range">
                <xs:annotation>
                    <xs:documentation>indicates that the range distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="sd">
                <xs:annotation>
                    <xs:documentation>indicates that the standard deviation distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="se">
                <xs:annotation>
                    <xs:documentation>indicates that the standard error distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="linear">
                <xs:annotation>
                    <xs:documentation>indicates that the linear distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="quadratic">
                <xs:annotation>
                    <xs:documentation>indicates that the quadratic distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cubic">
                <xs:annotation>
                    <xs:documentation>indicates that the cubic distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="polynomial">
                <xs:annotation>
                    <xs:documentation>indicates that the polynomial distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="piecewise">
                <xs:annotation>
                    <xs:documentation>indicates that the piecewise distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="confi">
                <xs:annotation>
                    <xs:documentation>indicates that the confidence interval distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="mad">
                <xs:annotation>
                    <xs:documentation>indicates that the mean absolute deviation distribution is to be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="kernelType">
        <xs:annotation>
            <xs:documentation>Specifies which kernel function to use in the calculation of statistics.  This is usually used for smooth statistics.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="uniform">
                <xs:annotation>
                    <xs:documentation>specifies that a uniform kernel should be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="epanechnikov">
                <xs:annotation>
                    <xs:documentation>specifies that a epanechnikov kernel should be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="biweight">
                <xs:annotation>
                    <xs:documentation>specifies that a biweight kernel should be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="triweight">
                <xs:annotation>
                    <xs:documentation>specifies that a triweight kernel should be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="tricube">
                <xs:annotation>
                    <xs:documentation>specifies that a tricube kernel should be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="gaussian">
                <xs:annotation>
                    <xs:documentation>specifies that a gaussian kernel should be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cauchy">
                <xs:annotation>
                    <xs:documentation>specifies that a cauchy kernel should be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="smoothMethodType">
        <xs:annotation>
            <xs:documentation>Used to dictates how to smooth data.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="linear">
                <xs:annotation>
                    <xs:documentation>specifies to fit a linear model to the data.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="loess">
                <xs:annotation>
                    <xs:documentation>specifies to fit a loess model to the data.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="power">
                <xs:annotation>
                    <xs:documentation>specifies to fit a power model to the data.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="quadratic">
                <xs:annotation>
                    <xs:documentation>specifies to fit a quadratic model to the data.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="monotonic">
                <xs:annotation>
                    <xs:documentation>specifies to fit a monotonic model to the data.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cubic">
                <xs:annotation>
                    <xs:documentation>specifies to fit a cubic model to the data.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="polynomial">
                <xs:annotation>
                    <xs:documentation>specifies to fit a polynomial model to the data.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="log">
                <xs:annotation>
                    <xs:documentation>specifies to fit a log model to the data.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="piecewise">
                <xs:annotation>
                    <xs:documentation>specifies to fit a piecewise linear model to the data.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="mean">
                <xs:annotation>
                    <xs:documentation>specifies to fit a simple mean model to the data.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="median">
                <xs:annotation>
                    <xs:documentation>specifies to fit a simple median model to the data.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="trim">
                <xs:annotation>
                    <xs:documentation>specifies to fit a trimmed mean model to the data.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="spline"/>
            <xs:enumeration value="step-left"/>
            <xs:enumeration value="step-right"/>
            <xs:enumeration value="step-center"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="robustType">
        <xs:annotation>
            <xs:documentation>States what method of calculating a robust statistic to use.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="andrews">
                <xs:annotation>
                    <xs:documentation>Specifies that the Andrews method should be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="biweight">
                <xs:annotation>
                    <xs:documentation>Specifies that the biweight method should be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cauchy">
                <xs:annotation>
                    <xs:documentation>Specifies that the Cauchy method should be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="fair">
                <xs:annotation>
                    <xs:documentation>Specifies that the fair method should be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="huber">
                <xs:annotation>
                    <xs:documentation>Specifies that the Huber method should be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="logistic">
                <xs:annotation>
                    <xs:documentation>Specifies that the logistic method should be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="talwar">
                <xs:annotation>
                    <xs:documentation>Specifies that the Talwar method should be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="welsch">
                <xs:annotation>
                    <xs:documentation>Specifies that the Welsch method should be used.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="windowType">
        <xs:annotation>
            <xs:documentation>Used to specify how to calculate the kernel window width.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="fixed">
                <xs:annotation>
                    <xs:documentation>Specifies that the window size is fixed across all data</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="knn">
                <xs:annotation>
                    <xs:documentation>Specifies that the window size varies across the data. For any given X value, the window width will be chosen so as to include the "k" nearest neighbors to that X value.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="summaryBaseType">
        <xs:annotation>
            <xs:documentation>The base of a pecentage for a statistic.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="global">
                <xs:annotation>
                    <xs:documentation>The percentage base should be calculated from the data for the whole chart or panel.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="aesthetic">
                <xs:annotation>
                    <xs:documentation>The percentage base should be calculated from the data within one or more aesthetics for chart or panel</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="coordinate">
                <xs:annotation>
                    <xs:documentation>The percentage base should be calculated from the data within one or more coordinates for chart or panel</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="summaryType">
        <xs:annotation>
            <xs:documentation>The various supported summary methods</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="mean">
                <xs:annotation>
                    <xs:documentation>the mean of the data</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="sum">
                <xs:annotation>
                    <xs:documentation>the sum of the data</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="midRange">
                <xs:annotation>
                    <xs:documentation>the middle of the range of the data.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="percent">
                <xs:annotation>
                    <xs:documentation>the percent of this group of data compared to the all the data</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="fraction">
                <xs:annotation>
                    <xs:documentation>the fraction of this group of data compared to all the data</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="count">
                <xs:annotation>
                    <xs:documentation>the number of individuals in the data</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="stddev">
                <xs:annotation>
                    <xs:documentation>the standard deviation for the data</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="stderr">
                <xs:annotation>
                    <xs:documentation>the standard error for the data</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="median">
                <xs:annotation>
                    <xs:documentation>the median for the data</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="variance">
                <xs:annotation>
                    <xs:documentation>the variance of the data</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cumulativeSum">
                <xs:annotation>
                    <xs:documentation>Summarize each category, and add it to the previous, through all the categories in the data</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cumulativeCount">
                <xs:annotation>
                    <xs:documentation>Count each category, and add it to the previous, through all the cateogries in the data</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cumulativeFraction">
                <xs:annotation>
                    <xs:documentation>Cumulative fraction across all cateogries in the data, the final value being 1</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cumulativePercent">
                <xs:annotation>
                    <xs:documentation>Cumulative percentage across all cateogries in the data, the final value being 100</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="confidenceIntervalOfMean">
                <xs:annotation>
                    <xs:documentation>the simple confidence interval for the mean.  This may be used as either a two value interval, or a one value extent.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="confidenceIntervalIndividual">
                <xs:annotation>
                    <xs:documentation>the simple confidence interval for individuals.  This may be used as either a two value interval, or a one value extent.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="max">
                <xs:annotation>
                    <xs:documentation>the maximum value for the data</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="min">
                <xs:annotation>
                    <xs:documentation>the minimum value for the data</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="range">
                <xs:annotation>
                    <xs:documentation>the range of values for data.  This may be used as either a two value interval, or a one value erangextent.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="treeLayoutMethodType">
        <xs:annotation>
            <xs:documentation>The various kinds of tree layouts</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="treemap">
                <xs:annotation>
                    <xs:documentation>Specifies a layout method based on mosaic plots, and similar to the treemap plot of Schniedermann.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="simple">
                <xs:annotation>
                    <xs:documentation>Specifies a top down traditional tree layout.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="frameGuide">
        <xs:annotation>
            <xs:documentation>A wireframe in 3D. The complete property determines whether or not to draw the part of the frame that is in front.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:guideType">
                    <xs:attribute name="complete" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>Whether or not to draw the part of the frame that is front.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="functionGuide">
        <xs:annotation>
            <xs:documentation>A function guide which plots a line or surface in terms of an equation.  The function guide has properties for the different dimensions (x, y, z).  The numberPoints property is used to control how many points should be used in drawing the line.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:guideType">
                    <xs:attribute name="name" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>The name of the guide.  The name is a human-readable string that may be used to name the guide in a legend or to be read by a screen reader. If not defined, the ID will be used instead.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="x" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>The equation for the x dimension.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="y" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>The equation for the y dimension.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="z" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>The equation for the z dimension.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="numberPoints" type="xs:int">
                        <xs:annotation>
                            <xs:documentation>The number of points to use in drawing the line that follows the 	function.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="attach">
        <xs:annotation>
            <xs:documentation>Sets positions using the values of another element.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID"/>
            <xs:attribute name="target" type="xs:IDREF" use="required">
                <xs:annotation>
                    <xs:documentation>target element to get the position from</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="sourceIDVariable" type="xs:IDREF" use="required">
                <xs:annotation>
                    <xs:documentation>This is the variable which will be used in the ownign element. For each occurance of this variable (which must be categorical) we will search for locations in the target element</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="targetIDVariable1" type="xs:IDREF" use="required">
                <xs:annotation>
                    <xs:documentation>The variable in the target element to match up against. when the sourceIDVariable matches this variable, we use that location</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="targetIDVariable2" type="xs:IDREF">
                <xs:annotation>
                    <xs:documentation>If the targetIDVariable1 does not provide a match, use this variable instead</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="lineGuide">
        <xs:annotation>
            <xs:documentation>A line guide. Paramters for the line giving coordinates to draw it at must be given. A position must be specified with the coordinate properties in data space; x,y,z,x1,x2,y1,y2. By using combinations it is  possible to create lines to be drawn in any 2D orientation, and lying at a z depth, for a particular facet. This guide can be used in 2D and 3D systems.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:guideType">
                    <xs:attribute name="name" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>The name of the guide.  The name is a human-readable string that may be used to name the guide in a legend or to be read by a screen reader. If not defined, the ID will be used instead.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="x" type="xs:string"/>
                    <xs:attribute name="y" type="xs:string"/>
                    <xs:attribute name="z" type="xs:string"/>
                    <xs:attribute name="x1" type="xs:string"/>
                    <xs:attribute name="x2" type="xs:string"/>
                    <xs:attribute name="y1" type="xs:string"/>
                    <xs:attribute name="y2" type="xs:string"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="planeGuide">
        <xs:annotation>
            <xs:documentation>A plane guide in 3D. The plane is drawn normal to an axis at the back of the coordinate system. The normal is specified by the normal attribute.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:guideType">
                    <xs:attribute name="normal" type="vis:axisType">
                        <xs:annotation>
                            <xs:documentation>The dimension of the normal.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="pointGuide">
        <xs:annotation>
            <xs:documentation>A point guide which is drawn using the glyph specifed by the style.  Coordinates are given to specifiy the location that it should be drawn at.  Possible coordinates are x,y,z.  This guide can be used in 2D and 3D systems.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:guideType">
                    <xs:attribute name="name" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>The name of the guide.  The name is a human-readable string that may be used to name the guide in a legend or to be read by a screen reader. If not defined, the ID will be used instead.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="x" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>x position in data space.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="y" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>y position in data space.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="z" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>z position in data space.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="guideType">
        <xs:sequence>
            <xs:element ref="vis:label" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element ref="vis:conditionalStyle" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="id" type="xs:ID"/>
        <xs:attribute name="style" type="xs:IDREF">
            <xs:annotation>
                <xs:documentation>The style for this guide.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="zOrder" type="xs:int">
            <xs:annotation>
                <xs:documentation>Integer which determines in what order things are drawn in.  If this is not specified things will draw in the order they are found in the specification.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:simpleType name="axisType">
        <xs:annotation>
            <xs:documentation>The various supported summary methods</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="x">
                <xs:annotation>
                    <xs:documentation>Used for the x axis</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="y">
                <xs:annotation>
                    <xs:documentation>Used for the y axis</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="z">
                <xs:annotation>
                    <xs:documentation>Used for the z axis</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="drillDownType">
        <xs:annotation>
            <xs:documentation>Interaction types allowed in drillDown element</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="onClick">
                <xs:annotation>
                    <xs:documentation>Drill down on a click.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="onMouseDown">
                <xs:annotation>
                    <xs:documentation>Drill down on the mouse button being pushed down.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="onMouseUp">
                <xs:annotation>
                    <xs:documentation>Drill down on the mouse button being release.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="onMouseOver">
                <xs:annotation>
                    <xs:documentation>Drill down if the mouse pointer goes over the glyph.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="onMouseOut">
                <xs:annotation>
                    <xs:documentation>Drill down when the mouse pointer leaves the glyph.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="selectionModeType">
        <xs:annotation>
            <xs:documentation>Used to describe a mode of selection.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="click">
                <xs:annotation>
                    <xs:documentation>Something is selected if it is clicked upon.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="rectangle">
                <xs:annotation>
                    <xs:documentation>Something is selected if it falls partially inside the bounds of a rectangle
specified by actions of the mouse.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="hover">
                <xs:annotation>
                    <xs:documentation>Something is selected if the pointer hovers over it.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="popup">
        <xs:annotation>
            <xs:documentation>Specifies that one wants popup interactivity with there visualization</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:element name="tokenMapping">
                    <xs:annotation>
                        <xs:documentation>Defines a token to be used in the popup via the tokenTemplate</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:sequence>
                            <xs:annotation>
                                <xs:documentation>how to modify the variable via sumamrization of formatting</xs:documentation>
                            </xs:annotation>
                            <xs:element ref="vis:summaryStatistic" minOccurs="0" maxOccurs="unbounded"/>
                            <xs:group ref="vis:format" minOccurs="0" maxOccurs="unbounded"/>
                        </xs:sequence>
                        <xs:attribute name="variable" type="xs:IDREF" use="required">
                            <xs:annotation>
                                <xs:documentation>The variable to use to get a value for the token</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="columnToken">
                            <xs:annotation>
                                <xs:documentation>The token to use for the column name</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="valueToken">
                            <xs:annotation>
                                <xs:documentation>The token to use for the value</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>
            <xs:attribute name="id" type="xs:ID" />
            <xs:attribute name="style" type="xs:IDREF">
                <xs:annotation>
                    <xs:documentation>A style for the popup (may not be honored in all output forms)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="target" type="xs:IDREF" use="required">
                <xs:annotation>
                    <xs:documentation>An element that should be targeted for the popup</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="tokenTemplate" type="xs:string">
                <xs:annotation>
                    <xs:documentation>The templlate for the popup</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="brushing">
        <xs:annotation>
            <xs:documentation>Specifies a brushing interactivity with a visualization. Brushing changes the rendering of
 element glyphs chosen by selection with the mouse.  A given brushing element describes what to brush based upon the 
 given target attribute.  Brushing occurrs accross the complete set of brushing elements in a manner determined by the 
 linkMode.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:annotation>
                    <xs:documentation>Specifies how to brush on the given aesthetic</xs:documentation>
                </xs:annotation>
                <xs:group ref="vis:aesthetic" minOccurs="0"/>
            </xs:sequence>
            <xs:attribute name="id" type="xs:ID" />
            <xs:attribute name="target" type="xs:IDREF" use="required">
                <xs:annotation>
                    <xs:documentation>An element that should be targeted for the brushing</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="splitting" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation>Whether to split the element up. If true elements will be split by the brushing
 action in the same way as they would be by a categorcial variable on an aesthetic.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="linkMode">
                <xs:annotation>
                    <xs:documentation>Set the mode in which this brushing element links to other elements.  This
                    property is used in determining which glyphs to brush accross the entire set of brushing elements in
                    a given visualization.</xs:documentation>
                </xs:annotation>
                <xs:simpleType>
                    <xs:restriction base="xs:string">
                        <xs:enumeration value="source">
                            <xs:annotation>
                                <xs:documentation>Source of brushing requests only.  Glyphs specified by other brushing
 elements of mode receiver and both will be brushed when glyphs of brushing elments of  mode source are selected.
 Glyphs will never brush in brushing elements of mode source.</xs:documentation>
                            </xs:annotation>
                        </xs:enumeration>
                        <xs:enumeration value="receiver">
                            <xs:annotation>
                                <xs:documentation>Recieves brushing requests only.  Glyphs specified by a brushing
 element of mode receiver will be brushed when glyphs specifed by brushing elments of type source and both are selected.
 Glyphs specified by brushing elements of mode receiver can not be selected.</xs:documentation>
                            </xs:annotation>
                        </xs:enumeration>
                        <xs:enumeration value="both">
                            <xs:annotation>
                                <xs:documentation>Receiver and source of brushing requests.  Selecting a glyph specifed
 by a brushing element of mode both will brush and cause those specified by other brush elements of mode receiver to
 brush.</xs:documentation>
                            </xs:annotation>
                        </xs:enumeration>
                    </xs:restriction>
                </xs:simpleType>
            </xs:attribute>
            <xs:attribute name="selectionMode" type="vis:selectionModeType">
                <xs:annotation>
                    <xs:documentation>Set the mode to use in selecting glyphs to brush.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="source" type="xs:IDREF" use="required">
                <xs:annotation>
                    <xs:documentation>The data source to brush on</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="drillDown">
        <xs:annotation>
            <xs:documentation>Specifies that one wants popup interactivity with there visualization</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="vis:variableReference" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="id" type="xs:ID" />
            <xs:attribute name="target" type="xs:IDREF" use="required">
                <xs:annotation>
                    <xs:documentation>An element that should be targeted for drill down</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="function" type="xs:string">
                <xs:annotation>
                    <xs:documentation>Used to construct a function call, such as to provide a javascript function for 'onClick'.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="interactionType" type="vis:drillDownType">
                <xs:annotation>
                    <xs:documentation>What type of interaction a drill down should occurr on.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="urlBase" type="xs:string"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="time">
        <xs:annotation>
            <xs:documentation>Defines cross-sectional animation</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID" />
            <xs:attribute name="dateFormatPattern" type="xs:string" default="">
                <xs:annotation>
                    <xs:documentation>A format for the date</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="duration" type="xs:double">
                <xs:annotation>
                    <xs:documentation>Duration of animation, in seconds.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="timeZone">
                <xs:annotation>
                    <xs:documentation>Time zone name, using java.util.TimeZone conventions.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="window" type="xs:double">
                <xs:annotation>
                    <xs:documentation>The animation window, in seconds. </xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="styleReference">
        <xs:complexType>
            <xs:attribute name="ref" type="xs:IDREF" use="required">
                <xs:annotation>
                    <xs:documentation>The id of the style being referenced</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="variableReference">
        <xs:complexType>
            <xs:attribute name="ref" type="xs:IDREF" use="required">
                <xs:annotation>
                    <xs:documentation>The id of the variable being referenced</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="domainReference">
        <xs:complexType>
            <xs:attribute name="ref" type="xs:IDREF" use="required">
                <xs:annotation>
                    <xs:documentation>The id of the domain being referenced</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="faceting">
        <xs:annotation>
            <xs:documentation>The faceting described by this element's children will be applied outside the coordinate system, creating cells in a table of charts.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice maxOccurs="unbounded">
                <xs:element ref="vis:variableReference"/>
                <xs:element ref="vis:unity"/>
                <xs:element ref="vis:blend"/>
                <xs:element ref="vis:cross"/>
                <xs:element ref="vis:bar"/>
                <xs:element ref="vis:dot"/>
                <xs:element ref="vis:nest"/>
            </xs:choice>
            <xs:attribute name="method" type="xs:string">
                <xs:annotation>
                    <xs:documentation>How to combine the facting with the main element expressions</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="id" type="xs:ID"/>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="sortType">
        <xs:sequence>
            <xs:element name="sortMove" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>Sort at the beginning or end of a categorical domain.
category will sort at the beginning if first is true, otherwise it will sort at the end.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:attribute name="id" type="xs:ID"/>
                    <xs:attribute name="first" type="xs:boolean">
                        <xs:annotation>
                            <xs:documentation>Whether the value sorts at the beginning or end</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="category" type="xs:string">
                        <xs:annotation>
                            <xs:documentation>The value to be used by this specification.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="id" type="xs:ID"/>
        <xs:attribute name="descending" type="xs:boolean" default="false">
            <xs:annotation>
                <xs:documentation>Whether to reverse the usual sorting order</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:element name="embeddedSource">
        <xs:annotation>
            <xs:documentation>The data for this source follows directly embedded in the XML</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="names" type="xs:string">
                    <xs:annotation>
                        <xs:documentation>The names of the columns. A semi-colon separated list with a backslash used as an escaping character</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="types" type="xs:string">
                    <xs:annotation>
                        <xs:documentation>The types of the columns. A semi-colon separated list of the same length as the names, with entries 'int', 'double' and 'string' used to define the types</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="row" type="xs:string" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation>
                        <xs:documentation>The rows of the data matrix. A semi-colon separated list of the same length as the names and typeswith a backslash used as an escaping character. An empty field is treated as missing</xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attribute name="id" type="xs:ID" >
                <xs:annotation>
                    <xs:documentation>Identifier for the source</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="streamingSource">
        <xs:annotation>
            <xs:documentation>A source of streaming data.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID" >
                <xs:annotation>
                    <xs:documentation>Identifier for the source</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="url" type="xs:anyURI" use="required">
                <xs:annotation>
                    <xs:documentation>A uri pointing to a jar file containin a streaming source</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="userSource">
        <xs:annotation>
            <xs:documentation>This source is left undefined by the specifcation. An object satisfying the Source interface must be passed to a visualization prior to any action on the vizualization. It must have the same ID as this source.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID" >
                <xs:annotation>
                    <xs:documentation>Identifier for the source</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="delimitedFileSource">
        <xs:annotation>
            <xs:documentation>A source of data residing in a delimited file. Excel-style CSV files are a good example.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID" >
                <xs:annotation>
                    <xs:documentation>Identifier for the source</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="fileName" type="xs:string">
                <xs:annotation>
                    <xs:documentation>The path to the file to access</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="delimiter" type="xs:string">
                <xs:annotation>
                    <xs:documentation>The string (usually a single character) that separates columns in the file</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="header" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation>If true, the file contains a header row with the names of the variables</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="databaseSource">
        <xs:annotation>
            <xs:documentation>A source of data on a SQL database</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID" >
                <xs:annotation>
                    <xs:documentation>Identifier for the source</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="url" type="xs:anyURI">
                <xs:annotation>
                    <xs:documentation>The URI giving the database location</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="driver" type="xs:string">
                <xs:annotation>
                    <xs:documentation>The class name of the driver to be used to access the database. If unspecified a default one will be used</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="user" type="xs:string">
                <xs:annotation>
                    <xs:documentation>The username to use to log onto the database</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="password" type="xs:string">
                <xs:annotation>
                    <xs:documentation>The password used to log onto the database</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="table" type="xs:string">
                <xs:annotation>
                    <xs:documentation>The database table to access. Cannot be used when 'query' is specified</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="where" type="xs:string">
                <xs:annotation>
                    <xs:documentation>The sql 'where' clause to use to filter data. Cannot be used when 'query' is specified.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="query" type="xs:string">
                <xs:annotation>
                    <xs:documentation>The sql query to send to the database. If this is specified, 'where' and 'table' must not be specified</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="animatedSource">
        <xs:annotation>
            <xs:documentation>A source that animates over the time values of another source.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="id" type="xs:ID" >
                <xs:annotation>
                    <xs:documentation>Identifier for the source</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="base" type="xs:IDREF" use="required">
                <xs:annotation>
                    <xs:documentation>The id of the base source to animate over</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="timeVariable" type="xs:IDREF" use="required">
                <xs:annotation>
                    <xs:documentation>The id of a source variable to use that defines the time of each row of the base data source</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="keyVariable" type="xs:IDREF">
                <xs:annotation>
                    <xs:documentation>The id of a source variable to be used as the key for the  source to be animated over. If null, the entire source is treated as one group</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="aestheticMapping">
        <xs:annotation>
            <xs:documentation>Mapping from a category to a aesthetic</xs:documentation>
        </xs:annotation>
        <xs:attribute name="from" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>Category for the aesthetic</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="id" type="xs:ID">
            <xs:annotation>
                <xs:documentation>Identifier for this element</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:element name="colorMapping">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:aestheticMapping">
                    <xs:attribute name="to" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:documentation>Color to map a category to </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="lengthMapping">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:aestheticMapping">
                    <xs:attribute name="to" type="vis:length" use="required">
                        <xs:annotation>
                            <xs:documentation>Length to map a category to </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="doubleMapping">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:aestheticMapping">
                    <xs:attribute name="to" use="required">
                        <xs:annotation>
                            <xs:documentation>(0 - 1) value to map a category to </xs:documentation>
                        </xs:annotation>
                        <xs:simpleType>
                            <xs:restriction base="xs:double">
                                <xs:minInclusive value="0"/>
                                <xs:maxInclusive value="1"/>
                            </xs:restriction>
                        </xs:simpleType>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="integerMapping">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:aestheticMapping">
                    <xs:attribute name="to" type="xs:integer" use="required">
                        <xs:annotation>
                            <xs:documentation>integer value 0 or greater</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="dashMapping">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:aestheticMapping">
                    <xs:attribute name="to" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:documentation>dash array of lengths</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="symbolMapping">
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="vis:aestheticMapping">
                    <xs:attribute name="to" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:documentation>symbol for a point</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="edgeType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="complete"/>
            <xs:enumeration value="minimalSpanning"/>
            <xs:enumeration value="nearestNeighbor"/>
            <xs:enumeration value="hull"/>
        </xs:restriction>
    </xs:simpleType>
</xs:schema>
